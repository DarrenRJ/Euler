use choose::*;
use factors::*;
use num::bigint::{BigUint, ToBigUint};
use palindrome::*;
use std::cmp;
use std::collections::HashSet;
use std::fs::File;
use std::io::prelude::*;
use util::*;
use std::collections::HashMap;

extern crate num;
extern crate primal;

//If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
// The sum of these multiples is 23.

//Find the sum of all the multiples of 3 or 5 below 1000.

pub fn p1() -> u64 {
    let mut sum = 0;

    for i in 3..1_000 {
        if (i % 3) == 0 || (i % 5) == 0 {
            sum += i;
        }
    }
    sum
    //    (3..1_000).filter( |x| x%3==0 || x%5==0 ).sum() // this is slower on my machine
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:

// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

// By considering the terms in the Fibonacci sequence whose values do not exceed four million,
// find the sum of the even-valued terms.

pub fn p2() -> u64 {
    let mut sum = 0;
    let mut last = 1;
    let mut current = 2;

    while current <= 4_000_000 {
        if current % 2 == 0 {
            sum += current;
        }
        let temp = last + current;
        last = current;
        current = temp;
    }
    sum
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

pub fn p3() -> u64 {
    let num = 600_851_475_143;

    let results = prime_factors(num);

    results[results.len() - 1]
}

// A palindromic number reads the same both ways.
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

// Find the largest palindrome made from the product of two 3-digit numbers.

pub fn p4() -> u64 {
    let mut palendrome: u32 = 0;
    for i in 111..1000 {
        for j in 111..1000 {
            let val = i * j;
            if val > palendrome && is_dec_palendrome(val) {
                palendrome = val;
            }
        }
    }
    palendrome as u64
}

// 2520 is the smallest number that can be divided by each of the numbers
// from 1 to 10 without any remainder.

// What is the smallest positive number that is evenly divisible
// by all of the numbers from 1 to 20?

pub fn p5() -> u64 {
    let mut val: u64 = 20;
    loop {
        if
        /*val%2 ==0 &&*/
        val%3 ==0 && /*val%4 ==0 && val%5 ==0 &&*/
           /*val%6 ==0 &&*/ val%7 ==0 && /*val%8 ==0 &&*/ val%9 ==0 &&
           /*val%10==0 &&*/ val%11==0 && /*val%12==0 &&*/ val%13==0 &&
           /*val%14==0 && val%15==0 && val%16==0 &&*/ val%17==0 &&
           /*val%18==0 &&*/ val%19==0
        /*&& val%20==0*/
        {
            break;
        }
        val += 20;
    }
    val
}

// The sum of the squares of the first ten natural numbers is,
// 12 + 22 + ... + 102 = 385

// The square of the sum of the first ten natural numbers is,
// (1 + 2 + ... + 10)2 = 552 = 3025

// Hence the difference between the sum of the squares of the first ten natural numbers
// and the square of the sum is 3025 − 385 = 2640.

// Find the difference between the sum of the squares of the first one hundred natural
// numbers and the square of the sum.
pub fn p6() -> u64 {
    let mut sum_square: u64 = 0;
    let mut square_sum: u64 = 0;

    for i in 1..101 {
        sum_square += i * i;
        square_sum += i;
    }
    square_sum *= square_sum;
    square_sum - sum_square
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
// we can see that the 6th prime is 13.

// What is the 10 001st prime number?
pub fn p7() -> u64 {
    primal::Primes::all().nth(10_001 - 1).unwrap() as u64
}

// 73167176531330624919225119674426574742355349194934
// 96983520312774506326239578318016984801869478851843
// 85861560789112949495459501737958331952853208805511
// 12540698747158523863050715693290963295227443043557
// 66896648950445244523161731856403098711121722383113
// 62229893423380308135336276614282806444486645238749
// 30358907296290491560440772390713810515859307960866
// 70172427121883998797908792274921901699720888093776
// 65727333001053367881220235421809751254540594752243
// 52584907711670556013604839586446706324415722155397
// 53697817977846174064955149290862569321978468622482
// 83972241375657056057490261407972968652414535100474
// 82166370484403199890008895243450658541227588666881
// 16427171479924442928230863465674813919123162824586
// 17866458359124566529476545682848912883142607690042
// 24219022671055626321111109370544217506941658960408
// 07198403850962455444362981230987879927244284909188
// 84580156166097919133875499200524063689912560717606
// 05886116467109405077541002256983155200055935729725
// 71636269561882670428252483600823257530420752963450

// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
// What is the value of this product?

pub fn p8() -> u64 {
    let num = vec![
        7, 3, 1, 6, 7, 1, 7, 6, 5, 3, 1, 3, 3, 0, 6, 2, 4, 9, 1, 9, 2, 2, 5, 1, 1, 9, 6, 7, 4, 4,
        2, 6, 5, 7, 4, 7, 4, 2, 3, 5, 5, 3, 4, 9, 1, 9, 4, 9, 3, 4, 9, 6, 9, 8, 3, 5, 2, 0, 3, 1,
        2, 7, 7, 4, 5, 0, 6, 3, 2, 6, 2, 3, 9, 5, 7, 8, 3, 1, 8, 0, 1, 6, 9, 8, 4, 8, 0, 1, 8, 6,
        9, 4, 7, 8, 8, 5, 1, 8, 4, 3, 8, 5, 8, 6, 1, 5, 6, 0, 7, 8, 9, 1, 1, 2, 9, 4, 9, 4, 9, 5,
        4, 5, 9, 5, 0, 1, 7, 3, 7, 9, 5, 8, 3, 3, 1, 9, 5, 2, 8, 5, 3, 2, 0, 8, 8, 0, 5, 5, 1, 1,
        1, 2, 5, 4, 0, 6, 9, 8, 7, 4, 7, 1, 5, 8, 5, 2, 3, 8, 6, 3, 0, 5, 0, 7, 1, 5, 6, 9, 3, 2,
        9, 0, 9, 6, 3, 2, 9, 5, 2, 2, 7, 4, 4, 3, 0, 4, 3, 5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5,
        0, 4, 4, 5, 2, 4, 4, 5, 2, 3, 1, 6, 1, 7, 3, 1, 8, 5, 6, 4, 0, 3, 0, 9, 8, 7, 1, 1, 1, 2,
        1, 7, 2, 2, 3, 8, 3, 1, 1, 3, 6, 2, 2, 2, 9, 8, 9, 3, 4, 2, 3, 3, 8, 0, 3, 0, 8, 1, 3, 5,
        3, 3, 6, 2, 7, 6, 6, 1, 4, 2, 8, 2, 8, 0, 6, 4, 4, 4, 4, 8, 6, 6, 4, 5, 2, 3, 8, 7, 4, 9,
        3, 0, 3, 5, 8, 9, 0, 7, 2, 9, 6, 2, 9, 0, 4, 9, 1, 5, 6, 0, 4, 4, 0, 7, 7, 2, 3, 9, 0, 7,
        1, 3, 8, 1, 0, 5, 1, 5, 8, 5, 9, 3, 0, 7, 9, 6, 0, 8, 6, 6, 7, 0, 1, 7, 2, 4, 2, 7, 1, 2,
        1, 8, 8, 3, 9, 9, 8, 7, 9, 7, 9, 0, 8, 7, 9, 2, 2, 7, 4, 9, 2, 1, 9, 0, 1, 6, 9, 9, 7, 2,
        0, 8, 8, 8, 0, 9, 3, 7, 7, 6, 6, 5, 7, 2, 7, 3, 3, 3, 0, 0, 1, 0, 5, 3, 3, 6, 7, 8, 8, 1,
        2, 2, 0, 2, 3, 5, 4, 2, 1, 8, 0, 9, 7, 5, 1, 2, 5, 4, 5, 4, 0, 5, 9, 4, 7, 5, 2, 2, 4, 3,
        5, 2, 5, 8, 4, 9, 0, 7, 7, 1, 1, 6, 7, 0, 5, 5, 6, 0, 1, 3, 6, 0, 4, 8, 3, 9, 5, 8, 6, 4,
        4, 6, 7, 0, 6, 3, 2, 4, 4, 1, 5, 7, 2, 2, 1, 5, 5, 3, 9, 7, 5, 3, 6, 9, 7, 8, 1, 7, 9, 7,
        7, 8, 4, 6, 1, 7, 4, 0, 6, 4, 9, 5, 5, 1, 4, 9, 2, 9, 0, 8, 6, 2, 5, 6, 9, 3, 2, 1, 9, 7,
        8, 4, 6, 8, 6, 2, 2, 4, 8, 2, 8, 3, 9, 7, 2, 2, 4, 1, 3, 7, 5, 6, 5, 7, 0, 5, 6, 0, 5, 7,
        4, 9, 0, 2, 6, 1, 4, 0, 7, 9, 7, 2, 9, 6, 8, 6, 5, 2, 4, 1, 4, 5, 3, 5, 1, 0, 0, 4, 7, 4,
        8, 2, 1, 6, 6, 3, 7, 0, 4, 8, 4, 4, 0, 3, 1, 9, 9, 8, 9, 0, 0, 0, 8, 8, 9, 5, 2, 4, 3, 4,
        5, 0, 6, 5, 8, 5, 4, 1, 2, 2, 7, 5, 8, 8, 6, 6, 6, 8, 8, 1, 1, 6, 4, 2, 7, 1, 7, 1, 4, 7,
        9, 9, 2, 4, 4, 4, 2, 9, 2, 8, 2, 3, 0, 8, 6, 3, 4, 6, 5, 6, 7, 4, 8, 1, 3, 9, 1, 9, 1, 2,
        3, 1, 6, 2, 8, 2, 4, 5, 8, 6, 1, 7, 8, 6, 6, 4, 5, 8, 3, 5, 9, 1, 2, 4, 5, 6, 6, 5, 2, 9,
        4, 7, 6, 5, 4, 5, 6, 8, 2, 8, 4, 8, 9, 1, 2, 8, 8, 3, 1, 4, 2, 6, 0, 7, 6, 9, 0, 0, 4, 2,
        2, 4, 2, 1, 9, 0, 2, 2, 6, 7, 1, 0, 5, 5, 6, 2, 6, 3, 2, 1, 1, 1, 1, 1, 0, 9, 3, 7, 0, 5,
        4, 4, 2, 1, 7, 5, 0, 6, 9, 4, 1, 6, 5, 8, 9, 6, 0, 4, 0, 8, 0, 7, 1, 9, 8, 4, 0, 3, 8, 5,
        0, 9, 6, 2, 4, 5, 5, 4, 4, 4, 3, 6, 2, 9, 8, 1, 2, 3, 0, 9, 8, 7, 8, 7, 9, 9, 2, 7, 2, 4,
        4, 2, 8, 4, 9, 0, 9, 1, 8, 8, 8, 4, 5, 8, 0, 1, 5, 6, 1, 6, 6, 0, 9, 7, 9, 1, 9, 1, 3, 3,
        8, 7, 5, 4, 9, 9, 2, 0, 0, 5, 2, 4, 0, 6, 3, 6, 8, 9, 9, 1, 2, 5, 6, 0, 7, 1, 7, 6, 0, 6,
        0, 5, 8, 8, 6, 1, 1, 6, 4, 6, 7, 1, 0, 9, 4, 0, 5, 0, 7, 7, 5, 4, 1, 0, 0, 2, 2, 5, 6, 9,
        8, 3, 1, 5, 5, 2, 0, 0, 0, 5, 5, 9, 3, 5, 7, 2, 9, 7, 2, 5, 7, 1, 6, 3, 6, 2, 6, 9, 5, 6,
        1, 8, 8, 2, 6, 7, 0, 4, 2, 8, 2, 5, 2, 4, 8, 3, 6, 0, 0, 8, 2, 3, 2, 5, 7, 5, 3, 0, 4, 2,
        0, 7, 5, 2, 9, 6, 3, 4, 5, 0,
    ];
    //let mut i = 0;
    let mut max: u64 = 0;

    for i in 0..(num.len() - 12) {
        let product: u64 = num[i + 0]
            * num[i + 1]
            * num[i + 2]
            * num[i + 3]
            * num[i + 4]
            * num[i + 5]
            * num[i + 6]
            * num[i + 7]
            * num[i + 8]
            * num[i + 9]
            * num[i + 10]
            * num[i + 11]
            * num[i + 12];
        if product > max {
            max = product;
        }
    }

    max
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
// a2 + b2 = c2

// For example, 32 + 42 = 9 + 16 = 25 = 52.

// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
pub fn p9() -> u64 {
    for i in 1..999 {
        for j in 1..999 - i {
            let k = 1000 - (j + i);

            if (i * i + j * j) == k * k {
                return i * j * k;
            }
        }
    }
    0
}

// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

// Find the sum of all the primes below two million.
pub fn p10() -> u64 {
    let sieve = primal::Sieve::new(2_000_000);
    let mut sum = 0;

    for prime in sieve.primes_from(2) {
        sum += prime
    }
    sum as u64
}

// In the 20×20 grid below,
// four numbers along a diagonal line have been marked in red.

// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
// 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
// 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
// 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
// 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

// What is the greatest product of four adjacent numbers in the same direction
// (up, down, left, right, or diagonally) in the 20×20 grid?

pub fn p11() -> u64 {
    let a = [
        [
            8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8,
        ],
        [
            49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
        ],
        [
            81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65,
        ],
        [
            52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
        ],
        [
            22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
        ],
        [
            24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
        ],
        [
            32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
        ],
        [
            67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21,
        ],
        [
            24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
        ],
        [
            21, 36, 23, 9, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
        ],
        [
            78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 4, 62, 16, 14, 9, 53, 56, 92,
        ],
        [
            16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
        ],
        [
            86, 56, 00, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
        ],
        [
            19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
        ],
        [
            4, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
        ],
        [
            88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
        ],
        [
            04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36,
        ],
        [
            20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16,
        ],
        [
            20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54,
        ],
        [
            1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48,
        ],
    ];

    let mut max_product: u64 = 0;

    // check vertical
    for i in 0..20 {
        for j in 0..17 {
            let product = a[j][i] * a[j + 1][i] * a[j + 2][i] * a[j + 3][i];
            if product > max_product {
                max_product = product;
            }
        }
    }
    // check horizontal
    for i in 0..20 {
        for j in 0..17 {
            let product = a[i][j] * a[i][j + 1] * a[i][j + 2] * a[i][j + 3];
            if product > max_product {
                max_product = product;
                //                println!( "{},{} {},{} {},{} {},{} product {}", i,j,i,j+1,i,j+2,i,j+3,max_product);
            }
        }
    }
    // check check SE diagnal
    //    println!("Checking SE diagnal");
    for i in 0..17 {
        for j in 0..17 {
            let product = a[i][j] * a[i + 1][j + 1] * a[i + 2][j + 2] * a[i + 3][j + 3];
            if product > max_product {
                max_product = product;
                //                println!( "{},{} {},{} {},{} {},{} product {}", i,j,i+1,j+1,i+2,j+2,i+3,j+3,max_product);
            }
        }
    }
    // check SW diagnal
    //    println!("Checking SW diagnal");
    for i in 0..17 {
        for j in 4..20 {
            let product = a[i][j] * a[i + 1][j - 1] * a[i + 2][j - 2] * a[i + 3][j - 3];
            if product > max_product {
                max_product = product;
                //                println!( "{},{} {},{} {},{} {},{} product {}", i,j,i+1,j-1,i+2,j-2,i+3,j-3,max_product);
            }
        }
    }
    max_product
}

// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
// The first ten terms would be:

// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:

//      1: 1
//      3: 1,3
//      6: 1,2,3,6
//     10: 1,2,5,10
//     15: 1,3,5,15
//     21: 1,3,7,21
//     28: 1,2,4,7,14,28

// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?

pub fn p12() -> u64 {
    let mut i: u64 = 1;
    let mut triangle: u64 = 0;

    loop {
        triangle = triangle + i;
        i += 1;
        // apparently numbers that have lots of divisors are multiples of 6
        // so check they are a multiple of 6 first
        if (triangle % 6 == 0) && divisor_count(triangle) >= 500 {
            return triangle;
        }
    }
}

// Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
pub fn p13() -> u64 {
    let mut sum: u64 = 0;
    let mut result = Vec::new();
    let mut value: u64 = 0;

    let values = [
        [
            3, 7, 1, 0, 7, 2, 8, 7, 5, 3, 3, 9, 0, 2, 1, 0, 2, 7, 9, 8, 7, 9, 7, 9, 9, 8, 2, 2, 0,
            8, 3, 7, 5, 9, 0, 2, 4, 6, 5, 1, 0, 1, 3, 5, 7, 4, 0, 2, 5, 0,
        ],
        [
            4, 6, 3, 7, 6, 9, 3, 7, 6, 7, 7, 4, 9, 0, 0, 0, 9, 7, 1, 2, 6, 4, 8, 1, 2, 4, 8, 9, 6,
            9, 7, 0, 0, 7, 8, 0, 5, 0, 4, 1, 7, 0, 1, 8, 2, 6, 0, 5, 3, 8,
        ],
        [
            7, 4, 3, 2, 4, 9, 8, 6, 1, 9, 9, 5, 2, 4, 7, 4, 1, 0, 5, 9, 4, 7, 4, 2, 3, 3, 3, 0, 9,
            5, 1, 3, 0, 5, 8, 1, 2, 3, 7, 2, 6, 6, 1, 7, 3, 0, 9, 6, 2, 9,
        ],
        [
            9, 1, 9, 4, 2, 2, 1, 3, 3, 6, 3, 5, 7, 4, 1, 6, 1, 5, 7, 2, 5, 2, 2, 4, 3, 0, 5, 6, 3,
            3, 0, 1, 8, 1, 1, 0, 7, 2, 4, 0, 6, 1, 5, 4, 9, 0, 8, 2, 5, 0,
        ],
        [
            2, 3, 0, 6, 7, 5, 8, 8, 2, 0, 7, 5, 3, 9, 3, 4, 6, 1, 7, 1, 1, 7, 1, 9, 8, 0, 3, 1, 0,
            4, 2, 1, 0, 4, 7, 5, 1, 3, 7, 7, 8, 0, 6, 3, 2, 4, 6, 6, 7, 6,
        ],
        [
            8, 9, 2, 6, 1, 6, 7, 0, 6, 9, 6, 6, 2, 3, 6, 3, 3, 8, 2, 0, 1, 3, 6, 3, 7, 8, 4, 1, 8,
            3, 8, 3, 6, 8, 4, 1, 7, 8, 7, 3, 4, 3, 6, 1, 7, 2, 6, 7, 5, 7,
        ],
        [
            2, 8, 1, 1, 2, 8, 7, 9, 8, 1, 2, 8, 4, 9, 9, 7, 9, 4, 0, 8, 0, 6, 5, 4, 8, 1, 9, 3, 1,
            5, 9, 2, 6, 2, 1, 6, 9, 1, 2, 7, 5, 8, 8, 9, 8, 3, 2, 7, 3, 8,
        ],
        [
            4, 4, 2, 7, 4, 2, 2, 8, 9, 1, 7, 4, 3, 2, 5, 2, 0, 3, 2, 1, 9, 2, 3, 5, 8, 9, 4, 2, 2,
            8, 7, 6, 7, 9, 6, 4, 8, 7, 6, 7, 0, 2, 7, 2, 1, 8, 9, 3, 1, 8,
        ],
        [
            4, 7, 4, 5, 1, 4, 4, 5, 7, 3, 6, 0, 0, 1, 3, 0, 6, 4, 3, 9, 0, 9, 1, 1, 6, 7, 2, 1, 6,
            8, 5, 6, 8, 4, 4, 5, 8, 8, 7, 1, 1, 6, 0, 3, 1, 5, 3, 2, 7, 6,
        ],
        [
            7, 0, 3, 8, 6, 4, 8, 6, 1, 0, 5, 8, 4, 3, 0, 2, 5, 4, 3, 9, 9, 3, 9, 6, 1, 9, 8, 2, 8,
            9, 1, 7, 5, 9, 3, 6, 6, 5, 6, 8, 6, 7, 5, 7, 9, 3, 4, 9, 5, 1,
        ],
        [
            6, 2, 1, 7, 6, 4, 5, 7, 1, 4, 1, 8, 5, 6, 5, 6, 0, 6, 2, 9, 5, 0, 2, 1, 5, 7, 2, 2, 3,
            1, 9, 6, 5, 8, 6, 7, 5, 5, 0, 7, 9, 3, 2, 4, 1, 9, 3, 3, 3, 1,
        ],
        [
            6, 4, 9, 0, 6, 3, 5, 2, 4, 6, 2, 7, 4, 1, 9, 0, 4, 9, 2, 9, 1, 0, 1, 4, 3, 2, 4, 4, 5,
            8, 1, 3, 8, 2, 2, 6, 6, 3, 3, 4, 7, 9, 4, 4, 7, 5, 8, 1, 7, 8,
        ],
        [
            9, 2, 5, 7, 5, 8, 6, 7, 7, 1, 8, 3, 3, 7, 2, 1, 7, 6, 6, 1, 9, 6, 3, 7, 5, 1, 5, 9, 0,
            5, 7, 9, 2, 3, 9, 7, 2, 8, 2, 4, 5, 5, 9, 8, 8, 3, 8, 4, 0, 7,
        ],
        [
            5, 8, 2, 0, 3, 5, 6, 5, 3, 2, 5, 3, 5, 9, 3, 9, 9, 0, 0, 8, 4, 0, 2, 6, 3, 3, 5, 6, 8,
            9, 4, 8, 8, 3, 0, 1, 8, 9, 4, 5, 8, 6, 2, 8, 2, 2, 7, 8, 2, 8,
        ],
        [
            8, 0, 1, 8, 1, 1, 9, 9, 3, 8, 4, 8, 2, 6, 2, 8, 2, 0, 1, 4, 2, 7, 8, 1, 9, 4, 1, 3, 9,
            9, 4, 0, 5, 6, 7, 5, 8, 7, 1, 5, 1, 1, 7, 0, 0, 9, 4, 3, 9, 0,
        ],
        [
            3, 5, 3, 9, 8, 6, 6, 4, 3, 7, 2, 8, 2, 7, 1, 1, 2, 6, 5, 3, 8, 2, 9, 9, 8, 7, 2, 4, 0,
            7, 8, 4, 4, 7, 3, 0, 5, 3, 1, 9, 0, 1, 0, 4, 2, 9, 3, 5, 8, 6,
        ],
        [
            8, 6, 5, 1, 5, 5, 0, 6, 0, 0, 6, 2, 9, 5, 8, 6, 4, 8, 6, 1, 5, 3, 2, 0, 7, 5, 2, 7, 3,
            3, 7, 1, 9, 5, 9, 1, 9, 1, 4, 2, 0, 5, 1, 7, 2, 5, 5, 8, 2, 9,
        ],
        [
            7, 1, 6, 9, 3, 8, 8, 8, 7, 0, 7, 7, 1, 5, 4, 6, 6, 4, 9, 9, 1, 1, 5, 5, 9, 3, 4, 8, 7,
            6, 0, 3, 5, 3, 2, 9, 2, 1, 7, 1, 4, 9, 7, 0, 0, 5, 6, 9, 3, 8,
        ],
        [
            5, 4, 3, 7, 0, 0, 7, 0, 5, 7, 6, 8, 2, 6, 6, 8, 4, 6, 2, 4, 6, 2, 1, 4, 9, 5, 6, 5, 0,
            0, 7, 6, 4, 7, 1, 7, 8, 7, 2, 9, 4, 4, 3, 8, 3, 7, 7, 6, 0, 4,
        ],
        [
            5, 3, 2, 8, 2, 6, 5, 4, 1, 0, 8, 7, 5, 6, 8, 2, 8, 4, 4, 3, 1, 9, 1, 1, 9, 0, 6, 3, 4,
            6, 9, 4, 0, 3, 7, 8, 5, 5, 2, 1, 7, 7, 7, 9, 2, 9, 5, 1, 4, 5,
        ],
        [
            3, 6, 1, 2, 3, 2, 7, 2, 5, 2, 5, 0, 0, 0, 2, 9, 6, 0, 7, 1, 0, 7, 5, 0, 8, 2, 5, 6, 3,
            8, 1, 5, 6, 5, 6, 7, 1, 0, 8, 8, 5, 2, 5, 8, 3, 5, 0, 7, 2, 1,
        ],
        [
            4, 5, 8, 7, 6, 5, 7, 6, 1, 7, 2, 4, 1, 0, 9, 7, 6, 4, 4, 7, 3, 3, 9, 1, 1, 0, 6, 0, 7,
            2, 1, 8, 2, 6, 5, 2, 3, 6, 8, 7, 7, 2, 2, 3, 6, 3, 6, 0, 4, 5,
        ],
        [
            1, 7, 4, 2, 3, 7, 0, 6, 9, 0, 5, 8, 5, 1, 8, 6, 0, 6, 6, 0, 4, 4, 8, 2, 0, 7, 6, 2, 1,
            2, 0, 9, 8, 1, 3, 2, 8, 7, 8, 6, 0, 7, 3, 3, 9, 6, 9, 4, 1, 2,
        ],
        [
            8, 1, 1, 4, 2, 6, 6, 0, 4, 1, 8, 0, 8, 6, 8, 3, 0, 6, 1, 9, 3, 2, 8, 4, 6, 0, 8, 1, 1,
            1, 9, 1, 0, 6, 1, 5, 5, 6, 9, 4, 0, 5, 1, 2, 6, 8, 9, 6, 9, 2,
        ],
        [
            5, 1, 9, 3, 4, 3, 2, 5, 4, 5, 1, 7, 2, 8, 3, 8, 8, 6, 4, 1, 9, 1, 8, 0, 4, 7, 0, 4, 9,
            2, 9, 3, 2, 1, 5, 0, 5, 8, 6, 4, 2, 5, 6, 3, 0, 4, 9, 4, 8, 3,
        ],
        [
            6, 2, 4, 6, 7, 2, 2, 1, 6, 4, 8, 4, 3, 5, 0, 7, 6, 2, 0, 1, 7, 2, 7, 9, 1, 8, 0, 3, 9,
            9, 4, 4, 6, 9, 3, 0, 0, 4, 7, 3, 2, 9, 5, 6, 3, 4, 0, 6, 9, 1,
        ],
        [
            1, 5, 7, 3, 2, 4, 4, 4, 3, 8, 6, 9, 0, 8, 1, 2, 5, 7, 9, 4, 5, 1, 4, 0, 8, 9, 0, 5, 7,
            7, 0, 6, 2, 2, 9, 4, 2, 9, 1, 9, 7, 1, 0, 7, 9, 2, 8, 2, 0, 9,
        ],
        [
            5, 5, 0, 3, 7, 6, 8, 7, 5, 2, 5, 6, 7, 8, 7, 7, 3, 0, 9, 1, 8, 6, 2, 5, 4, 0, 7, 4, 4,
            9, 6, 9, 8, 4, 4, 5, 0, 8, 3, 3, 0, 3, 9, 3, 6, 8, 2, 1, 2, 6,
        ],
        [
            1, 8, 3, 3, 6, 3, 8, 4, 8, 2, 5, 3, 3, 0, 1, 5, 4, 6, 8, 6, 1, 9, 6, 1, 2, 4, 3, 4, 8,
            7, 6, 7, 6, 8, 1, 2, 9, 7, 5, 3, 4, 3, 7, 5, 9, 4, 6, 5, 1, 5,
        ],
        [
            8, 0, 3, 8, 6, 2, 8, 7, 5, 9, 2, 8, 7, 8, 4, 9, 0, 2, 0, 1, 5, 2, 1, 6, 8, 5, 5, 5, 4,
            8, 2, 8, 7, 1, 7, 2, 0, 1, 2, 1, 9, 2, 5, 7, 7, 6, 6, 9, 5, 4,
        ],
        [
            7, 8, 1, 8, 2, 8, 3, 3, 7, 5, 7, 9, 9, 3, 1, 0, 3, 6, 1, 4, 7, 4, 0, 3, 5, 6, 8, 5, 6,
            4, 4, 9, 0, 9, 5, 5, 2, 7, 0, 9, 7, 8, 6, 4, 7, 9, 7, 5, 8, 1,
        ],
        [
            1, 6, 7, 2, 6, 3, 2, 0, 1, 0, 0, 4, 3, 6, 8, 9, 7, 8, 4, 2, 5, 5, 3, 5, 3, 9, 9, 2, 0,
            9, 3, 1, 8, 3, 7, 4, 4, 1, 4, 9, 7, 8, 0, 6, 8, 6, 0, 9, 8, 4,
        ],
        [
            4, 8, 4, 0, 3, 0, 9, 8, 1, 2, 9, 0, 7, 7, 7, 9, 1, 7, 9, 9, 0, 8, 8, 2, 1, 8, 7, 9, 5,
            3, 2, 7, 3, 6, 4, 4, 7, 5, 6, 7, 5, 5, 9, 0, 8, 4, 8, 0, 3, 0,
        ],
        [
            8, 7, 0, 8, 6, 9, 8, 7, 5, 5, 1, 3, 9, 2, 7, 1, 1, 8, 5, 4, 5, 1, 7, 0, 7, 8, 5, 4, 4,
            1, 6, 1, 8, 5, 2, 4, 2, 4, 3, 2, 0, 6, 9, 3, 1, 5, 0, 3, 3, 2,
        ],
        [
            5, 9, 9, 5, 9, 4, 0, 6, 8, 9, 5, 7, 5, 6, 5, 3, 6, 7, 8, 2, 1, 0, 7, 0, 7, 4, 9, 2, 6,
            9, 6, 6, 5, 3, 7, 6, 7, 6, 3, 2, 6, 2, 3, 5, 4, 4, 7, 2, 1, 0,
        ],
        [
            6, 9, 7, 9, 3, 9, 5, 0, 6, 7, 9, 6, 5, 2, 6, 9, 4, 7, 4, 2, 5, 9, 7, 7, 0, 9, 7, 3, 9,
            1, 6, 6, 6, 9, 3, 7, 6, 3, 0, 4, 2, 6, 3, 3, 9, 8, 7, 0, 8, 5,
        ],
        [
            4, 1, 0, 5, 2, 6, 8, 4, 7, 0, 8, 2, 9, 9, 0, 8, 5, 2, 1, 1, 3, 9, 9, 4, 2, 7, 3, 6, 5,
            7, 3, 4, 1, 1, 6, 1, 8, 2, 7, 6, 0, 3, 1, 5, 0, 0, 1, 2, 7, 1,
        ],
        [
            6, 5, 3, 7, 8, 6, 0, 7, 3, 6, 1, 5, 0, 1, 0, 8, 0, 8, 5, 7, 0, 0, 9, 1, 4, 9, 9, 3, 9,
            5, 1, 2, 5, 5, 7, 0, 2, 8, 1, 9, 8, 7, 4, 6, 0, 0, 4, 3, 7, 5,
        ],
        [
            3, 5, 8, 2, 9, 0, 3, 5, 3, 1, 7, 4, 3, 4, 7, 1, 7, 3, 2, 6, 9, 3, 2, 1, 2, 3, 5, 7, 8,
            1, 5, 4, 9, 8, 2, 6, 2, 9, 7, 4, 2, 5, 5, 2, 7, 3, 7, 3, 0, 7,
        ],
        [
            9, 4, 9, 5, 3, 7, 5, 9, 7, 6, 5, 1, 0, 5, 3, 0, 5, 9, 4, 6, 9, 6, 6, 0, 6, 7, 6, 8, 3,
            1, 5, 6, 5, 7, 4, 3, 7, 7, 1, 6, 7, 4, 0, 1, 8, 7, 5, 2, 7, 5,
        ],
        [
            8, 8, 9, 0, 2, 8, 0, 2, 5, 7, 1, 7, 3, 3, 2, 2, 9, 6, 1, 9, 1, 7, 6, 6, 6, 8, 7, 1, 3,
            8, 1, 9, 9, 3, 1, 8, 1, 1, 0, 4, 8, 7, 7, 0, 1, 9, 0, 2, 7, 1,
        ],
        [
            2, 5, 2, 6, 7, 6, 8, 0, 2, 7, 6, 0, 7, 8, 0, 0, 3, 0, 1, 3, 6, 7, 8, 6, 8, 0, 9, 9, 2,
            5, 2, 5, 4, 6, 3, 4, 0, 1, 0, 6, 1, 6, 3, 2, 8, 6, 6, 5, 2, 6,
        ],
        [
            3, 6, 2, 7, 0, 2, 1, 8, 5, 4, 0, 4, 9, 7, 7, 0, 5, 5, 8, 5, 6, 2, 9, 9, 4, 6, 5, 8, 0,
            6, 3, 6, 2, 3, 7, 9, 9, 3, 1, 4, 0, 7, 4, 6, 2, 5, 5, 9, 6, 2,
        ],
        [
            2, 4, 0, 7, 4, 4, 8, 6, 9, 0, 8, 2, 3, 1, 1, 7, 4, 9, 7, 7, 7, 9, 2, 3, 6, 5, 4, 6, 6,
            2, 5, 7, 2, 4, 6, 9, 2, 3, 3, 2, 2, 8, 1, 0, 9, 1, 7, 1, 4, 1,
        ],
        [
            9, 1, 4, 3, 0, 2, 8, 8, 1, 9, 7, 1, 0, 3, 2, 8, 8, 5, 9, 7, 8, 0, 6, 6, 6, 9, 7, 6, 0,
            8, 9, 2, 9, 3, 8, 6, 3, 8, 2, 8, 5, 0, 2, 5, 3, 3, 3, 4, 0, 3,
        ],
        [
            3, 4, 4, 1, 3, 0, 6, 5, 5, 7, 8, 0, 1, 6, 1, 2, 7, 8, 1, 5, 9, 2, 1, 8, 1, 5, 0, 0, 5,
            5, 6, 1, 8, 6, 8, 8, 3, 6, 4, 6, 8, 4, 2, 0, 0, 9, 0, 4, 7, 0,
        ],
        [
            2, 3, 0, 5, 3, 0, 8, 1, 1, 7, 2, 8, 1, 6, 4, 3, 0, 4, 8, 7, 6, 2, 3, 7, 9, 1, 9, 6, 9,
            8, 4, 2, 4, 8, 7, 2, 5, 5, 0, 3, 6, 6, 3, 8, 7, 8, 4, 5, 8, 3,
        ],
        [
            1, 1, 4, 8, 7, 6, 9, 6, 9, 3, 2, 1, 5, 4, 9, 0, 2, 8, 1, 0, 4, 2, 4, 0, 2, 0, 1, 3, 8,
            3, 3, 5, 1, 2, 4, 4, 6, 2, 1, 8, 1, 4, 4, 1, 7, 7, 3, 4, 7, 0,
        ],
        [
            6, 3, 7, 8, 3, 2, 9, 9, 4, 9, 0, 6, 3, 6, 2, 5, 9, 6, 6, 6, 4, 9, 8, 5, 8, 7, 6, 1, 8,
            2, 2, 1, 2, 2, 5, 2, 2, 5, 5, 1, 2, 4, 8, 6, 7, 6, 4, 5, 3, 3,
        ],
        [
            6, 7, 7, 2, 0, 1, 8, 6, 9, 7, 1, 6, 9, 8, 5, 4, 4, 3, 1, 2, 4, 1, 9, 5, 7, 2, 4, 0, 9,
            9, 1, 3, 9, 5, 9, 0, 0, 8, 9, 5, 2, 3, 1, 0, 0, 5, 8, 8, 2, 2,
        ],
        [
            9, 5, 5, 4, 8, 2, 5, 5, 3, 0, 0, 2, 6, 3, 5, 2, 0, 7, 8, 1, 5, 3, 2, 2, 9, 6, 7, 9, 6,
            2, 4, 9, 4, 8, 1, 6, 4, 1, 9, 5, 3, 8, 6, 8, 2, 1, 8, 7, 7, 4,
        ],
        [
            7, 6, 0, 8, 5, 3, 2, 7, 1, 3, 2, 2, 8, 5, 7, 2, 3, 1, 1, 0, 4, 2, 4, 8, 0, 3, 4, 5, 6,
            1, 2, 4, 8, 6, 7, 6, 9, 7, 0, 6, 4, 5, 0, 7, 9, 9, 5, 2, 3, 6,
        ],
        [
            3, 7, 7, 7, 4, 2, 4, 2, 5, 3, 5, 4, 1, 1, 2, 9, 1, 6, 8, 4, 2, 7, 6, 8, 6, 5, 5, 3, 8,
            9, 2, 6, 2, 0, 5, 0, 2, 4, 9, 1, 0, 3, 2, 6, 5, 7, 2, 9, 6, 7,
        ],
        [
            2, 3, 7, 0, 1, 9, 1, 3, 2, 7, 5, 7, 2, 5, 6, 7, 5, 2, 8, 5, 6, 5, 3, 2, 4, 8, 2, 5, 8,
            2, 6, 5, 4, 6, 3, 0, 9, 2, 2, 0, 7, 0, 5, 8, 5, 9, 6, 5, 2, 2,
        ],
        [
            2, 9, 7, 9, 8, 8, 6, 0, 2, 7, 2, 2, 5, 8, 3, 3, 1, 9, 1, 3, 1, 2, 6, 3, 7, 5, 1, 4, 7,
            3, 4, 1, 9, 9, 4, 8, 8, 9, 5, 3, 4, 7, 6, 5, 7, 4, 5, 5, 0, 1,
        ],
        [
            1, 8, 4, 9, 5, 7, 0, 1, 4, 5, 4, 8, 7, 9, 2, 8, 8, 9, 8, 4, 8, 5, 6, 8, 2, 7, 7, 2, 6,
            0, 7, 7, 7, 1, 3, 7, 2, 1, 4, 0, 3, 7, 9, 8, 8, 7, 9, 7, 1, 5,
        ],
        [
            3, 8, 2, 9, 8, 2, 0, 3, 7, 8, 3, 0, 3, 1, 4, 7, 3, 5, 2, 7, 7, 2, 1, 5, 8, 0, 3, 4, 8,
            1, 4, 4, 5, 1, 3, 4, 9, 1, 3, 7, 3, 2, 2, 6, 6, 5, 1, 3, 8, 1,
        ],
        [
            3, 4, 8, 2, 9, 5, 4, 3, 8, 2, 9, 1, 9, 9, 9, 1, 8, 1, 8, 0, 2, 7, 8, 9, 1, 6, 5, 2, 2,
            4, 3, 1, 0, 2, 7, 3, 9, 2, 2, 5, 1, 1, 2, 2, 8, 6, 9, 5, 3, 9,
        ],
        [
            4, 0, 9, 5, 7, 9, 5, 3, 0, 6, 6, 4, 0, 5, 2, 3, 2, 6, 3, 2, 5, 3, 8, 0, 4, 4, 1, 0, 0,
            0, 5, 9, 6, 5, 4, 9, 3, 9, 1, 5, 9, 8, 7, 9, 5, 9, 3, 6, 3, 5,
        ],
        [
            2, 9, 7, 4, 6, 1, 5, 2, 1, 8, 5, 5, 0, 2, 3, 7, 1, 3, 0, 7, 6, 4, 2, 2, 5, 5, 1, 2, 1,
            1, 8, 3, 6, 9, 3, 8, 0, 3, 5, 8, 0, 3, 8, 8, 5, 8, 4, 9, 0, 3,
        ],
        [
            4, 1, 6, 9, 8, 1, 1, 6, 2, 2, 2, 0, 7, 2, 9, 7, 7, 1, 8, 6, 1, 5, 8, 2, 3, 6, 6, 7, 8,
            4, 2, 4, 6, 8, 9, 1, 5, 7, 9, 9, 3, 5, 3, 2, 9, 6, 1, 9, 2, 2,
        ],
        [
            6, 2, 4, 6, 7, 9, 5, 7, 1, 9, 4, 4, 0, 1, 2, 6, 9, 0, 4, 3, 8, 7, 7, 1, 0, 7, 2, 7, 5,
            0, 4, 8, 1, 0, 2, 3, 9, 0, 8, 9, 5, 5, 2, 3, 5, 9, 7, 4, 5, 7,
        ],
        [
            2, 3, 1, 8, 9, 7, 0, 6, 7, 7, 2, 5, 4, 7, 9, 1, 5, 0, 6, 1, 5, 0, 5, 5, 0, 4, 9, 5, 3,
            9, 2, 2, 9, 7, 9, 5, 3, 0, 9, 0, 1, 1, 2, 9, 9, 6, 7, 5, 1, 9,
        ],
        [
            8, 6, 1, 8, 8, 0, 8, 8, 2, 2, 5, 8, 7, 5, 3, 1, 4, 5, 2, 9, 5, 8, 4, 0, 9, 9, 2, 5, 1,
            2, 0, 3, 8, 2, 9, 0, 0, 9, 4, 0, 7, 7, 7, 0, 7, 7, 5, 6, 7, 2,
        ],
        [
            1, 1, 3, 0, 6, 7, 3, 9, 7, 0, 8, 3, 0, 4, 7, 2, 4, 4, 8, 3, 8, 1, 6, 5, 3, 3, 8, 7, 3,
            5, 0, 2, 3, 4, 0, 8, 4, 5, 6, 4, 7, 0, 5, 8, 0, 7, 7, 3, 0, 8,
        ],
        [
            8, 2, 9, 5, 9, 1, 7, 4, 7, 6, 7, 1, 4, 0, 3, 6, 3, 1, 9, 8, 0, 0, 8, 1, 8, 7, 1, 2, 9,
            0, 1, 1, 8, 7, 5, 4, 9, 1, 3, 1, 0, 5, 4, 7, 1, 2, 6, 5, 8, 1,
        ],
        [
            9, 7, 6, 2, 3, 3, 3, 1, 0, 4, 4, 8, 1, 8, 3, 8, 6, 2, 6, 9, 5, 1, 5, 4, 5, 6, 3, 3, 4,
            9, 2, 6, 3, 6, 6, 5, 7, 2, 8, 9, 7, 5, 6, 3, 4, 0, 0, 5, 0, 0,
        ],
        [
            4, 2, 8, 4, 6, 2, 8, 0, 1, 8, 3, 5, 1, 7, 0, 7, 0, 5, 2, 7, 8, 3, 1, 8, 3, 9, 4, 2, 5,
            8, 8, 2, 1, 4, 5, 5, 2, 1, 2, 2, 7, 2, 5, 1, 2, 5, 0, 3, 2, 7,
        ],
        [
            5, 5, 1, 2, 1, 6, 0, 3, 5, 4, 6, 9, 8, 1, 2, 0, 0, 5, 8, 1, 7, 6, 2, 1, 6, 5, 2, 1, 2,
            8, 2, 7, 6, 5, 2, 7, 5, 1, 6, 9, 1, 2, 9, 6, 8, 9, 7, 7, 8, 9,
        ],
        [
            3, 2, 2, 3, 8, 1, 9, 5, 7, 3, 4, 3, 2, 9, 3, 3, 9, 9, 4, 6, 4, 3, 7, 5, 0, 1, 9, 0, 7,
            8, 3, 6, 9, 4, 5, 7, 6, 5, 8, 8, 3, 3, 5, 2, 3, 9, 9, 8, 8, 6,
        ],
        [
            7, 5, 5, 0, 6, 1, 6, 4, 9, 6, 5, 1, 8, 4, 7, 7, 5, 1, 8, 0, 7, 3, 8, 1, 6, 8, 8, 3, 7,
            8, 6, 1, 0, 9, 1, 5, 2, 7, 3, 5, 7, 9, 2, 9, 7, 0, 1, 3, 3, 7,
        ],
        [
            6, 2, 1, 7, 7, 8, 4, 2, 7, 5, 2, 1, 9, 2, 6, 2, 3, 4, 0, 1, 9, 4, 2, 3, 9, 9, 6, 3, 9,
            1, 6, 8, 0, 4, 4, 9, 8, 3, 9, 9, 3, 1, 7, 3, 3, 1, 2, 7, 3, 1,
        ],
        [
            3, 2, 9, 2, 4, 1, 8, 5, 7, 0, 7, 1, 4, 7, 3, 4, 9, 5, 6, 6, 9, 1, 6, 6, 7, 4, 6, 8, 7,
            6, 3, 4, 6, 6, 0, 9, 1, 5, 0, 3, 5, 9, 1, 4, 6, 7, 7, 5, 0, 4,
        ],
        [
            9, 9, 5, 1, 8, 6, 7, 1, 4, 3, 0, 2, 3, 5, 2, 1, 9, 6, 2, 8, 8, 9, 4, 8, 9, 0, 1, 0, 2,
            4, 2, 3, 3, 2, 5, 1, 1, 6, 9, 1, 3, 6, 1, 9, 6, 2, 6, 6, 2, 2,
        ],
        [
            7, 3, 2, 6, 7, 4, 6, 0, 8, 0, 0, 5, 9, 1, 5, 4, 7, 4, 7, 1, 8, 3, 0, 7, 9, 8, 3, 9, 2,
            8, 6, 8, 5, 3, 5, 2, 0, 6, 9, 4, 6, 9, 4, 4, 5, 4, 0, 7, 2, 4,
        ],
        [
            7, 6, 8, 4, 1, 8, 2, 2, 5, 2, 4, 6, 7, 4, 4, 1, 7, 1, 6, 1, 5, 1, 4, 0, 3, 6, 4, 2, 7,
            9, 8, 2, 2, 7, 3, 3, 4, 8, 0, 5, 5, 5, 5, 6, 2, 1, 4, 8, 1, 8,
        ],
        [
            9, 7, 1, 4, 2, 6, 1, 7, 9, 1, 0, 3, 4, 2, 5, 9, 8, 6, 4, 7, 2, 0, 4, 5, 1, 6, 8, 9, 3,
            9, 8, 9, 4, 2, 2, 1, 7, 9, 8, 2, 6, 0, 8, 8, 0, 7, 6, 8, 5, 2,
        ],
        [
            8, 7, 7, 8, 3, 6, 4, 6, 1, 8, 2, 7, 9, 9, 3, 4, 6, 3, 1, 3, 7, 6, 7, 7, 5, 4, 3, 0, 7,
            8, 0, 9, 3, 6, 3, 3, 3, 3, 0, 1, 8, 9, 8, 2, 6, 4, 2, 0, 9, 0,
        ],
        [
            1, 0, 8, 4, 8, 8, 0, 2, 5, 2, 1, 6, 7, 4, 6, 7, 0, 8, 8, 3, 2, 1, 5, 1, 2, 0, 1, 8, 5,
            8, 8, 3, 5, 4, 3, 2, 2, 3, 8, 1, 2, 8, 7, 6, 9, 5, 2, 7, 8, 6,
        ],
        [
            7, 1, 3, 2, 9, 6, 1, 2, 4, 7, 4, 7, 8, 2, 4, 6, 4, 5, 3, 8, 6, 3, 6, 9, 9, 3, 0, 0, 9,
            0, 4, 9, 3, 1, 0, 3, 6, 3, 6, 1, 9, 7, 6, 3, 8, 7, 8, 0, 3, 9,
        ],
        [
            6, 2, 1, 8, 4, 0, 7, 3, 5, 7, 2, 3, 9, 9, 7, 9, 4, 2, 2, 3, 4, 0, 6, 2, 3, 5, 3, 9, 3,
            8, 0, 8, 3, 3, 9, 6, 5, 1, 3, 2, 7, 4, 0, 8, 0, 1, 1, 1, 1, 6,
        ],
        [
            6, 6, 6, 2, 7, 8, 9, 1, 9, 8, 1, 4, 8, 8, 0, 8, 7, 7, 9, 7, 9, 4, 1, 8, 7, 6, 8, 7, 6,
            1, 4, 4, 2, 3, 0, 0, 3, 0, 9, 8, 4, 4, 9, 0, 8, 5, 1, 4, 1, 1,
        ],
        [
            6, 0, 6, 6, 1, 8, 2, 6, 2, 9, 3, 6, 8, 2, 8, 3, 6, 7, 6, 4, 7, 4, 4, 7, 7, 9, 2, 3, 9,
            1, 8, 0, 3, 3, 5, 1, 1, 0, 9, 8, 9, 0, 6, 9, 7, 9, 0, 7, 1, 4,
        ],
        [
            8, 5, 7, 8, 6, 9, 4, 4, 0, 8, 9, 5, 5, 2, 9, 9, 0, 6, 5, 3, 6, 4, 0, 4, 4, 7, 4, 2, 5,
            5, 7, 6, 0, 8, 3, 6, 5, 9, 9, 7, 6, 6, 4, 5, 7, 9, 5, 0, 9, 6,
        ],
        [
            6, 6, 0, 2, 4, 3, 9, 6, 4, 0, 9, 9, 0, 5, 3, 8, 9, 6, 0, 7, 1, 2, 0, 1, 9, 8, 2, 1, 9,
            9, 7, 6, 0, 4, 7, 5, 9, 9, 4, 9, 0, 1, 9, 7, 2, 3, 0, 2, 9, 7,
        ],
        [
            6, 4, 9, 1, 3, 9, 8, 2, 6, 8, 0, 0, 3, 2, 9, 7, 3, 1, 5, 6, 0, 3, 7, 1, 2, 0, 0, 4, 1,
            3, 7, 7, 9, 0, 3, 7, 8, 5, 5, 6, 6, 0, 8, 5, 0, 8, 9, 2, 5, 2,
        ],
        [
            1, 6, 7, 3, 0, 9, 3, 9, 3, 1, 9, 8, 7, 2, 7, 5, 0, 2, 7, 5, 4, 6, 8, 9, 0, 6, 9, 0, 3,
            7, 0, 7, 5, 3, 9, 4, 1, 3, 0, 4, 2, 6, 5, 2, 3, 1, 5, 0, 1, 1,
        ],
        [
            9, 4, 8, 0, 9, 3, 7, 7, 2, 4, 5, 0, 4, 8, 7, 9, 5, 1, 5, 0, 9, 5, 4, 1, 0, 0, 9, 2, 1,
            6, 4, 5, 8, 6, 3, 7, 5, 4, 7, 1, 0, 5, 9, 8, 4, 3, 6, 7, 9, 1,
        ],
        [
            7, 8, 6, 3, 9, 1, 6, 7, 0, 2, 1, 1, 8, 7, 4, 9, 2, 4, 3, 1, 9, 9, 5, 7, 0, 0, 6, 4, 1,
            9, 1, 7, 9, 6, 9, 7, 7, 7, 5, 9, 9, 0, 2, 8, 3, 0, 0, 6, 9, 9,
        ],
        [
            1, 5, 3, 6, 8, 7, 1, 3, 7, 1, 1, 9, 3, 6, 6, 1, 4, 9, 5, 2, 8, 1, 1, 3, 0, 5, 8, 7, 6,
            3, 8, 0, 2, 7, 8, 4, 1, 0, 7, 5, 4, 4, 4, 9, 7, 3, 3, 0, 7, 8,
        ],
        [
            4, 0, 7, 8, 9, 9, 2, 3, 1, 1, 5, 5, 3, 5, 5, 6, 2, 5, 6, 1, 1, 4, 2, 3, 2, 2, 4, 2, 3,
            2, 5, 5, 0, 3, 3, 6, 8, 5, 4, 4, 2, 4, 8, 8, 9, 1, 7, 3, 5, 3,
        ],
        [
            4, 4, 8, 8, 9, 9, 1, 1, 5, 0, 1, 4, 4, 0, 6, 4, 8, 0, 2, 0, 3, 6, 9, 0, 6, 8, 0, 6, 3,
            9, 6, 0, 6, 7, 2, 3, 2, 2, 1, 9, 3, 2, 0, 4, 1, 4, 9, 5, 3, 5,
        ],
        [
            4, 1, 5, 0, 3, 1, 2, 8, 8, 8, 0, 3, 3, 9, 5, 3, 6, 0, 5, 3, 2, 9, 9, 3, 4, 0, 3, 6, 8,
            0, 0, 6, 9, 7, 7, 7, 1, 0, 6, 5, 0, 5, 6, 6, 6, 3, 1, 9, 5, 4,
        ],
        [
            8, 1, 2, 3, 4, 8, 8, 0, 6, 7, 3, 2, 1, 0, 1, 4, 6, 7, 3, 9, 0, 5, 8, 5, 6, 8, 5, 5, 7,
            9, 3, 4, 5, 8, 1, 4, 0, 3, 6, 2, 7, 8, 2, 2, 7, 0, 3, 2, 8, 0,
        ],
        [
            8, 2, 6, 1, 6, 5, 7, 0, 7, 7, 3, 9, 4, 8, 3, 2, 7, 5, 9, 2, 2, 3, 2, 8, 4, 5, 9, 4, 1,
            7, 0, 6, 5, 2, 5, 0, 9, 4, 5, 1, 2, 3, 2, 5, 2, 3, 0, 6, 0, 8,
        ],
        [
            2, 2, 9, 1, 8, 8, 0, 2, 0, 5, 8, 7, 7, 7, 3, 1, 9, 7, 1, 9, 8, 3, 9, 4, 5, 0, 1, 8, 0,
            8, 8, 8, 0, 7, 2, 4, 2, 9, 6, 6, 1, 9, 8, 0, 8, 1, 1, 1, 9, 7,
        ],
        [
            7, 7, 1, 5, 8, 5, 4, 2, 5, 0, 2, 0, 1, 6, 5, 4, 5, 0, 9, 0, 4, 1, 3, 2, 4, 5, 8, 0, 9,
            7, 8, 6, 8, 8, 2, 7, 7, 8, 9, 4, 8, 7, 2, 1, 8, 5, 9, 6, 1, 7,
        ],
        [
            7, 2, 1, 0, 7, 8, 3, 8, 4, 3, 5, 0, 6, 9, 1, 8, 6, 1, 5, 5, 4, 3, 5, 6, 6, 2, 8, 8, 4,
            0, 6, 2, 2, 5, 7, 4, 7, 3, 6, 9, 2, 2, 8, 4, 5, 0, 9, 5, 1, 6,
        ],
        [
            2, 0, 8, 4, 9, 6, 0, 3, 9, 8, 0, 1, 3, 4, 0, 0, 1, 7, 2, 3, 9, 3, 0, 6, 7, 1, 6, 6, 6,
            8, 2, 3, 5, 5, 5, 2, 4, 5, 2, 5, 2, 8, 0, 4, 6, 0, 9, 7, 2, 2,
        ],
        [
            5, 3, 5, 0, 3, 5, 3, 4, 2, 2, 6, 4, 7, 2, 5, 2, 4, 2, 5, 0, 8, 7, 4, 0, 5, 4, 0, 7, 5,
            5, 9, 1, 7, 8, 9, 7, 8, 1, 2, 6, 4, 3, 3, 0, 3, 3, 1, 6, 9, 0,
        ],
    ];

    for i in 0..values[0].len() {
        for j in 0..values.len() {
            sum += values[j][values[0].len() - (i + 1)];
        }
        result.push(sum % 10);
        sum /= 10;
    }
    while sum != 0 {
        result.push(sum % 10);
        sum /= 10;
    }

    //     println!("The last 10 digits of Sum are" );
    for i in 0..9 {
        //         println!("{}", result[result.len()-(i+1)] );
        value *= 10;
        value += result[result.len() - (i + 1)];
    }
    value
}

// The following iterative sequence is defined for the set of positive integers:

// n → n/2 (n is even)
// n → 3n + 1 (n is odd)

// Using the rule above and starting with 13, we generate the following sequence:
// 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

// It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

// Which starting number, under one million, produces the longest chain?

// NOTE: Once the chain starts the terms are allowed to go above one million.
fn collatz(start_num: u64) -> u64 {
    let mut length = 1;
    let mut number = start_num;

    while number != 1 {
        length += 1;
        if (number & 0x01) != 0 {
            number = (number * 3) + 1;
        } else {
            number >>= 1;
        }
    }
    return length;
}

/*
fn longest_collatz( highest : usize ) -> u64
{
    let mut max_length = 0;
    let mut number = 0;
    let mut seen : [bool; 1_000_001] = [false;1_000_001];
    for i in 0..highest
    {
        let val : usize = highest-i;
        if seen[val]
        {
            continue;
        }

        let mut length = 1;
        while number != 1
        {
            seen[number] = true;
            length += 1;
            if (number & 0x01) != 0
            {
                number = (number * 3) + 1;
            }
            else
            {
                number >>= 1;
            }
        }
        if length > max_length
        {
            max_length = length;
            number = val;
        }
    }
    number as u64
}
*/
pub fn p14() -> u64 {
    let mut max_length = 1;
    let mut best_value = 1;

    //     longest_collatz(1_000_000)
    for i in 1..1000000 {
        let length = collatz(i);
        if length > max_length {
            best_value = i;
            max_length = length;
        }
    }

    best_value
}

// Starting in the top left corner of a 2×2 grid,
// and only being able to move to the right and down,
// there are exactly 6 routes to the bottom right corner.

// How many such routes are there through a 20×20 grid?

pub fn p15() -> u64 {
    // the answer is 40 choose 20
    return n_choose_k(40, 20);
}

// 215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.

// What is the sum of the digits of the number 21000?

pub fn p16() -> u64 {
    let mut sum = 0;
    let mut big_int = vec![0; 1000 / 3];
    big_int[0] = 2; // 1st power of two
                    // for powers of two from 2 to 1000
    for _i in 1..1000 {
        let mut carry = 0;
        for j in 0..big_int.len() {
            big_int[j] *= 2;
            big_int[j] += carry;
            carry = big_int[j] / 10;
            big_int[j] %= 10;
        }
    }

    for i in big_int {
        sum += i;
    }
    sum
}

// If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.

// If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?

// NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.
pub fn p17() -> u64 {
    let mut sum: u32 = 0;
    for i in 0..1000 {
        let numb_str = stringify(i + 1);
        let chars = count_chars(numb_str.clone());
        sum += chars;
        //        println!("{} \"{}\" has {}", i+1, numb_str, chars);
    }
    sum as u64
}

// Find the maximum total from top to bottom of the triangle below:

//                75
//              95 64
//             17 47 82
//            18 35 87 10
//           20 04 82 47 65
//          19 01 23 75 03 34
//         88 02 77 73 07 63 67
//        99 65 04 28 06 16 70 92
//       41 41 26 56 83 40 80 70 33
//      41 48 72 33 47 32 37 16 94 29
//     53 71 44 65 25 43 91 52 97 51 14
//    70 11 33 28 77 73 17 78 39 68 17 57
//   91 71 52 38 17 14 91 43 58 50 27 29 48
//  63 66 04 68 89 53 67 30 73 16 69 87 40 31
// 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

pub fn p18() -> u64 {
    let mut triangle = vec![
        vec![4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23],
        vec![63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
        vec![91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
        vec![70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
        vec![53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
        vec![41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
        vec![41, 41, 26, 56, 83, 40, 80, 70, 33],
        vec![99, 65, 4, 28, 6, 16, 70, 92],
        vec![88, 2, 77, 73, 7, 63, 67],
        vec![19, 1, 23, 75, 3, 34],
        vec![20, 4, 82, 47, 65],
        vec![18, 35, 87, 10],
        vec![17, 47, 82],
        vec![95, 64],
        vec![75],
    ];

    for row in 0..triangle.len() - 1 {
        for col in 0..triangle[row].len() - 1 {
            triangle[row + 1][col] += cmp::max(triangle[row][col], triangle[row][col + 1]);
        }
    }
    triangle[triangle.len() - 1][0]
}

pub fn p19() -> u64 {
    let days_in_month = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    let mut days = 2; // jan 1st 1901 is a Tuesday, which is 2 days past Sunday
    let mut matching = 0;

    // for years 1901 to 2000
    for year in 1901..2001 {
        // for each month in the year
        for month in 0..12 {
            // if the first day of the month is a sunday
            if days % 7 == 0 {
                matching += 1;
                //                println!("month {} in year {} is on a Sunday", month+1, year );
            }
            days += days_in_month[month];
            // if we are feb on a leap year
            if month == 1 && is_leap(year) {
                //                println!("{} is a leap year", year );
                days += 1;
            }
        }
    }
    matching
}

// n! means n × (n − 1) × ... × 3 × 2 × 1
// For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
// and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
// Find the sum of the digits in the number 100!

pub fn p20() -> u64 {
    let mut digit_sum: u64 = 0;
    let mut big_num = "100".parse::<BigUint>().unwrap();

    for i in 2..100 {
        let b = i.to_biguint().unwrap();
        big_num = big_num * b;
    }

    let digits = big_num.to_str_radix(10);
    for i in digits.as_bytes() {
        digit_sum += (i - 0x30) as u64;
    }

    digit_sum
}

// Let d(n) be defined as the sum of proper divisors of n
// (numbers less than n which divide evenly into n).
// If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair
// and each of a and b are called amicable numbers.
// For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110;
// therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
// Evaluate the sum of all the amicable numbers under 10000.
pub fn p21() -> u64 {
    let mut amicable = Vec::new();
    let mut divisor_sums = Vec::new();
    let mut sum_of_amicable: u64 = 0;

    // find the sum of the divisors for the numbers unser 10000
    for i in 0..10000 {
        let divisors = proper_divisors(i);
        let mut sum: u64 = 0;
        for j in divisors {
            sum += j;
        }
        divisor_sums.push(sum);
    }

    // find all the amicable numbers
    for i in 0..10000 {
        let div_sum = divisor_sums[i];
        // only check forwards so we only do it once
        // also check the length before we index
        if (div_sum > i as u64) && (div_sum < divisor_sums.len() as u64) {
            // if the sum of the value indexed by i == i then these two numbers are amicable
            if divisor_sums[div_sum as usize] == i as u64 {
                amicable.push(i);
                amicable.push(div_sum as usize);
            }
        }
    }

    for i in amicable {
        sum_of_amicable += i as u64;
    }

    sum_of_amicable
}

// Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing
// over five-thousand first names, begin by sorting it into alphabetical order.
// Then working out the alphabetical value for each name, multiply this value by its alphabetical
// position in the list to obtain a name score.
// For example, when the list is sorted into alphabetical order, COLIN, which is worth
// 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of
// 938 × 53 = 49714.
// What is the total of all the name scores in the file?

pub fn p22() -> u64 {
    let mut total = 0;
    let mut alphabetic_val = Vec::new();

    // open the file
    let mut file = File::open("p022_names.txt").expect("file not found");

    // read the file into a string
    let mut s = String::new();
    file.read_to_string(&mut s).expect("could not read file");

    // get all the names in the names array
    let mut v: Vec<&str> = s.split(',').collect();

    //    println!("split v[937] = {}", v[937] );

    // remove the bounding '"'
    for i in 0..v.len() {
        v[i] = &v[i][1..v[i].len() - 1];
    }

    //    println!("stripped v[937] = {}", v[937] );

    // sort the vector
    v.sort();

    //    println!("sorted v[937] = {}", v[937] );

    for name in v {
        let mut value = 0;
        for letter in name.chars() {
            value += match letter.to_digit(36) {
                Some(val) => val,
                None => 0,
            } - 9;
        }
        alphabetic_val.push(value);
    }

    for i in 0..alphabetic_val.len() {
        total += alphabetic_val[i] * (i as u32 + 1);
    }

    //    println!("v[937] value = {}", alphabetic_val[937] );
    total as u64
}

// A perfect number is a number for which the sum of its proper divisors is exactly equal
// to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28,
// which means that 28 is a perfect number.
// A number n is called deficient if the sum of its proper divisors is less than n
// and it is called abundant if this sum exceeds n.
// As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16,
// the smallest number that can be written as the sum of two abundant numbers is 24.
// By mathematical analysis, it can be shown that all integers greater than 28123
// can be written as the sum of two abundant numbers.
// However, this upper limit cannot be reduced any further by analysis
// even though it is known that the greatest number that cannot be expressed as the sum
// of two abundant numbers is less than this limit.
// Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.

pub fn p23() -> u64 {
    let mut abundents = Vec::new();
    let mut abundent_array = [false; 28124];
    //    let mut set = HashSet::new();
    //    let mut bitmap : [ u64; 28187/64 ] = [0; 28187/64 ];
    let mut sum = 0;

    // get a vector of abundent numbers less than 28123
    for i in 1..28123 {
        let factor_sum = sum_of_proper_divisors(i);
        if factor_sum > i as u64 {
            abundents.push(i);
            abundent_array[i as usize] = true;
        }
    }

    for i in 1..28124 {
        let max = i / 2;
        let mut fail = false;
        for abundant in &abundents {
            if *abundant > max {
                break;
            }
            if abundent_array[(i - *abundant) as usize] {
                fail = true;
            }
        }
        if !fail {
            sum += i;
        }
    }

    sum as u64
}

// What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
pub fn p24() -> u64 {
    let mut digits: Vec<u64> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    permutate(&mut digits, 999_999);

    (digits[0] * 1_000_000_000)
        + (digits[1] * 100_000_000)
        + (digits[2] * 10_000_000)
        + (digits[3] * 1_000_000)
        + (digits[4] * 100_000)
        + (digits[5] * 10_000)
        + (digits[6] * 1_000)
        + (digits[7] * 100)
        + (digits[8] * 10)
        + digits[9]
}

// What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
pub fn p25() -> u64 {
    let mut current = Vec::new();
    let mut last = Vec::new();

    // set up the two arays
    for _i in 0..999 {
        current.push(0);
        last.push(0);
    }

    current.push(1);
    last.push(1);

    let mut fib_num = 2;

    // start generating more numbers
    loop {
        let mut carry: u64 = 0;
        let temp = current.clone();
        fib_num += 1;

        for i in 0..current.len() {
            let index = current.len() - (i + 1);
            let digit = current[index] + last[index] + carry % 10;

            current[index] = digit % 10;
            carry = carry / 10 + digit / 10;
        }
        last = temp;
        if current[0] != 0 {
            break;
        }
    }
    fib_num
}

// Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
pub fn p26() -> u64 {
    let mut longest_sequence = 0;
    let mut longest_index = 0;

    let max_val = 1000;

    // for the source range
    for i in 1..max_val {
        // go from highest to lowest
        let index = max_val - i;

        // if we get to an index that is smaller than the bigest sequence
        // bail, as the sequence can only be as large as the index
        if index < longest_sequence {
            break;
        }
        let mut remainders_hit = vec![0; index];

        let mut value = 1;
        let mut seq_len = 0;

        // while we have not hit this remainder yet
        while remainders_hit[value] == 0 {
            // save the fact we have had this remainder
            remainders_hit[value] = seq_len;
            // calculate the next remainder
            value *= 10;
            value %= index;
            seq_len += 1;
            // if our value hits 0 bail as this is a non repeating sequence
            if value == 0 {
                break;
            }
        }

        if seq_len > longest_sequence {
            longest_sequence = seq_len;
            longest_index = index;
        }
    }
    longest_index as u64
    //    println!("The longest sequence is at index {} and has {} digits", longest_index, longest_sequence );
}

// Find the product of the coefficients, a and b, for the quadratic expression that
// produces the maximum number of primes for consecutive values of n, starting with n=0.
pub fn p27() -> i64 {
    let mut run_of_primes = 0;
    let mut a_sol = 0;
    let mut b_sol = 0;
    let sieve = primal::Sieve::new(80000);

    for a in -999..1000 {
        for b in primal::Sieve::new(1001).primes_from(2) {
            let mut i = 0;

            while sieve.is_prime(quadratic(a, b as i64, i) as usize) {
                i += 1;
            }
            if i > run_of_primes {
                run_of_primes = i;
                a_sol = a;
                b_sol = b;
            }
        }
    }
    (a_sol) * (b_sol as i64)
}

// Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:

// 21 22 23 24 25
// 20  7  8  9 10
// 19  6  1  2 11
// 18  5  4  3 12
// 17 16 15 14 13

// It can be verified that the sum of the numbers on the diagonals is 101.
// What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?

pub fn p28() -> u64 {
    let mut sum: u64 = 1; // start with the middle number
                          //    let mut nums = 1;

    // add the corner numbers spiriling outward
    for i in 1..501
    // 500 values
    {
        let index = (i * 2) + 1;
        let top_right = index * index;
        let low_right = (index * index) - (3 * index) + 3;
        let low_left = (index * index) - (2 * index) + 2;
        let top_left = (index * index) - (1 * index) + 1;

        sum += top_right + low_right + low_left + top_left;
        //        nums += 4;
    }

    //    println!("sum = {} accross {} numbers", sum, nums );
    sum
}

// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

//     22=4, 23=8, 24=16, 25=32
//     32=9, 33=27, 34=81, 35=243
//     42=16, 43=64, 44=256, 45=1024
//     52=25, 53=125, 54=625, 55=3125

// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

pub fn p29() -> u64 {
    let mut set = HashSet::new();
    for a in 2..101 {
        for b in 2..101 {
            let value = a.to_biguint().unwrap();
            let pow = num::pow(value, b);
            set.insert(pow);
        }
    }
    //    println!("num values = {}", set.len() );
    set.len() as u64
}

// Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:

//     1634 = 14 + 64 + 34 + 44
//     8208 = 84 + 24 + 04 + 84
//     9474 = 94 + 44 + 74 + 44

// As 1 = 14 is not a sum it is not included.

// The sum of these numbers is 1634 + 8208 + 9474 = 19316.

// Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.

pub fn p30() -> u64 {
    let mut sum: u64 = 0;

    for i in 2..295_245 {
        let mut div: u64 = i;
        let mut power_5_sum: u64 = 0;
        while div > 0 && power_5_sum <= i {
            power_5_sum += match div % 10 {
                1 => 1,
                2 => 32,
                3 => 243,
                4 => 1024,
                5 => 3125,
                6 => 7776,
                7 => 16807,
                8 => 32768,
                9 => 59049,
                _ => 0,
            };
            div /= 10;
        }

        if i == power_5_sum {
            sum += i;
            //            println!("{} = {}^5 {}^5 {}^5 {}^5 {}^5", i, i/10000, (i/1000)%10, (i/100)%10, (i/10)%10, i%10 );
        }
    }

    //    println!("sum = {}", sum );
    sum
}

// In England the currency is made up of pound, £, and pence, p,
// and there are eight coins in general circulation:

//     1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).

// It is possible to make £2 in the following way:

//     1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p

// How many different ways can £2 be made using any number of coins?

pub fn p31() -> u64 {
    let mut sum = 1; // start with 1 representing the 2 pound coin

    // 1 poind coins
    for i in 0..(200 / 100) + 1 {
        let isum = i * 100;

        // 50p coins
        for j in 0..((200 - isum) / 50) + 1 {
            let jsum = isum + j * 50;

            // 20p coins
            for k in 0..((200 - jsum) / 20) + 1 {
                let ksum = jsum + k * 20;

                // 10p coins
                for l in 0..((200 - ksum) / 10) + 1 {
                    let lsum = ksum + l * 10;

                    // 5p coins
                    for m in 0..((200 - lsum) / 5) + 1 {
                        let msum = lsum + m * 5;

                        // 2p coins
                        for n in 0..((200 - msum) / 2) + 1 {
                            let nsum = msum + n * 2;

                            // 1p coins
                            for o in 0..((200 - nsum) / 1) + 1 {
                                let osum = nsum + o;
                                if osum == 200 {
                                    sum += 1;
                                    //println!("{}*100p {}*50p {}*10p {}*5p {}*2p {}*1p", i, j, k, l, m, n );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //    println!("sum = {}", sum );
    sum
}

// We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

// The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.

// Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
// HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.

pub fn p32() -> u64 {
    let mut digits: Vec<u64> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut sum = 0;
    let mut results = HashSet::new();

    loop {
        for mul_1_size in 1..3 {
            let mut mul_1 = 0;
            for i in 0..mul_1_size {
                mul_1 *= 10;
                mul_1 += digits[i];
            }
            for mul_2_size in 3..5 {
                let mut mul_2 = 0;
                for i in 0..mul_2_size {
                    mul_2 *= 10;
                    mul_2 += digits[mul_1_size + i];
                }
                let mut product = 0;
                for i in 0..9 - mul_1_size - mul_2_size {
                    product *= 10;
                    product += digits[mul_1_size + mul_2_size + i];
                }

                if mul_1 * mul_2 >= product {
                    if mul_1 * mul_2 == product {
                        results.insert(product);
                        //                    println!("{} * {} = {}", mul_1, mul_2, product );
                    }
                    break;
                }
            }
        }
        permutate(&mut digits, 1);
        if (digits[0] == 9)
            && (digits[1] == 8)
            && (digits[2] == 7)
            && (digits[3] == 6)
            && (digits[4] == 5)
            && (digits[5] == 4)
            && (digits[6] == 3)
            && (digits[7] == 2)
            && (digits[8] == 1)
        {
            break;
        }
    }

    for number in results {
        sum += number;
    }

    sum
}

// The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting
// to simplify it may incorrectly believe that 49/98 = 4/8, which is correct,
// is obtained by cancelling the 9s.

// We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

// There are exactly four non-trivial examples of this type of fraction, less than one in value,
// and containing two digits in the numerator and denominator.

// If the product of these four fractions is given in its lowest common terms,
// find the value of the denominator.

pub fn p33() -> u64 {
    let mut n_prod = 1;
    let mut d_prod = 1;

    for numerator in 11..100 {
        if numerator % 10 == 0 {
            continue;
        }
        for denominator in numerator..100 {
            if (numerator == denominator) || (denominator % 10 == 0) {
                continue;
            }
            if numerator % 10 == denominator / 10 {
                let (n1, d1) = reduce_fraction(numerator, denominator);
                let (n2, d2) = reduce_fraction(numerator / 10, denominator % 10);

                if (n1 == n2) && (d1 == d2) {
                    //                    println!("{}/{} = {}/{} = {}/{}", numerator, denominator,
                    //                            numerator/10, denominator%10, n1, d1 );
                    n_prod *= n1;
                    d_prod *= d1;
                }
            }
        }
    }
    let (_n_common, d_common) = reduce_fraction(n_prod, d_prod);
    //    println!( "n={} d={}", n_common, d_common );
    d_common as u64
}

// 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.

// Find the sum of all numbers which are equal to the sum of the factorial of their digits.

// Note: as 1! = 1 and 2! = 2 are not sums they are not included.
pub fn p34() -> u64 {
    let facorial = vec![1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880];
    let mut total_sum = 0;

    for i in 3..2540160 {
        let mut digit_fact_sum = 0;
        let mut temp = i;

        while temp != 0 {
            digit_fact_sum += facorial[temp % 10];
            temp /= 10;
        }
        if digit_fact_sum == i {
            //            println!("{} is a digit factorial", i);
            total_sum += i;
        }
    }
    //    println!("sum = {}", total_sum );
    total_sum as u64
}

// The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.

// There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.

// How many circular primes are there below one million?
pub fn p35() -> u64 {
    let sieve = primal::Sieve::new(1_000_000);
    let mut num_circ_primes = 1; // we start at 3 so add 1 for 2
    let mut i = 3;

    while i < 1_000_000 {
        if sieve.is_prime(i) {
            let mut found_non_prime = false;
            let mut temp = i;
            let digits = (i as f32).log(10.0) as usize;
            //            println!("{} is prime", i);
            loop {
                // shift the lowest digit into the highest digit position
                temp = (temp / 10) + ((temp % 10) * (10 as usize).pow(digits as u32));

                // test for primality
                if !sieve.is_prime(temp) {
                    found_non_prime = true;
                    //                    println!("{} is NOT prime", temp);
                    break;
                }

                //                println!("{} is prime", temp);

                // exit when we are back to the original number
                // note it allows shortcuts if we test like this :)
                if temp == i {
                    break;
                }
            }
            if !found_non_prime {
                num_circ_primes += 1;
                //                println!("{} is a circular prime", i);
            }
        }
        i += 2; // after 2 all the primes are odd, so count by 2's
    }

    //    println!("found {} circular primes", num_circ_primes );
    num_circ_primes
}

// The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.

// Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.

// (Please note that the palindromic number, in either base, may not include leading zeros.)
pub fn p36() -> u64 {
    let mut i = 1;
    let mut sum = 0;

    while i < 1_000_000 {
        if is_bin_palandrome(i) && is_dec_palendrome(i) {
            sum += i;
        }

        i += 2; // only odd numbers can be a palendrome in binary
    }
    sum as u64
}

// The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.

// Find the sum of the only eleven primes that are both truncatable from left to right and right to left.

// NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
pub fn p37() -> u64 {
    let sieve = primal::Sieve::new(1_000_000);
    let mut sum = 0;
    //    let mut num = 0;

    // check the prime sieve from 11 which is the first candidate
    for i in sieve.primes_from(11) {
        if is_trunc(i as u32, &sieve) {
            sum += i;
            //            num += 1;
        }
    }

    //    println!("sum of {} numbers is {}", num, sum );
    sum as u64
}

pub fn p38() -> u64 {
    let mut larget_pandigital = 0;
    for i in 1..99_999 {
        if let Some(value) = pandigital_product(i) {
            if value > larget_pandigital {
                //                println!("{} creates {} = ", i, value);
                larget_pandigital = value;
            }
        }
    }
    larget_pandigital as u64
}

pub fn p39() -> u64 {
    let mut count: Vec<u16> = vec![0; 1001];

    // if the perimeter is <= 1000 then each edge <= 500
    for i in 1..500 {
        let i_squared = i * i;
        // if i is odd j must be odd and if i is even j must be even so start j at i+2
        for j in i + 2..500 {
            // check that i*j is divisable by 12
            if i * j % 12 == 0 {
                let sum_square = i_squared + (j * j);
                let hypot_f = (sum_square as f32).sqrt();
                let hypot_i = hypot_f as usize;
                if hypot_i as f32 == hypot_f {
                    let perimeter = hypot_i + i + j;
                    if perimeter < count.len() {
                        count[perimeter] += 1;
                    }
                }
            }
        }
    }
    // check every even perimeter count
    let mut max = 0;
    let mut max_val = 0;
    for i in 0..count.len() / 2 {
        let index = i * 2;
        if count[index] > max_val {
            max_val = count[index];
            max = index;
        }
    }
    max as u64
}

pub fn p40() -> u64 {
    digit_num(1)
        * digit_num(10)
        * digit_num(100)
        * digit_num(1_000)
        * digit_num(10_000)
        * digit_num(100_000)
        * digit_num(1_000_000) as u64
}

pub fn p41() -> u64 {
    let sieve = primal::Sieve::new(7654321); // cant be 8 or 9 digits, so do 7
    let mut digits: Vec<u64> = vec![1, 2, 3, 4, 5, 6, 7];
    let mut largest = 0;

    while digits != vec![7, 6, 5, 4, 3, 2, 1] {
        permutate(&mut digits, 1);

        // if it is an even number skip this one
        if digits[digits.len() - 1] % 2 == 0 {
            continue;
        }

        let mut value = 0;
        for i in 0..digits.len() {
            value *= 10;
            value += digits[i];
        }
        if value > largest && sieve.is_prime(value as usize) {
            largest = value;
        }
    }
    largest as u64
}

pub fn word_value(word: &str) -> usize {
    let result: u32 = word.chars().map(|c| c as u32 - ('A' as u32 - 1)).sum();
    result as usize
}

pub fn p42() -> u64 {
    // open the file
    let mut file = File::open("p042_words.txt").expect("file not found");

    // read the file into a string
    let mut s = String::new();
    file.read_to_string(&mut s).expect("could not read file");

    // get all the words in the names array
    let v: Vec<&str> = s.split(',').collect();

    // generate an array of bools indicating if the index is a triangle number
    // the largest word is 14 chars so assuming it is all 'Z's the table has to
    // go up to 14*26 = 364, so the real max is somewhat less than this (probably half)
    let mut is_triangle = [false; 200];
    let mut generated = 1;
    let mut delta = 2;
    while generated < 200 {
        is_triangle[generated] = true;
        generated += delta;
        delta += 1;
    }

    // count the number of words whose word value is a triangle number
    // notice also we strip the leading and trailing '"' quotation marks off the words here
    let result: usize = v
        .into_iter()
        .filter(|x| is_triangle[word_value(&x[1..x.len() - 1])])
        .count();
    result as u64
}

pub fn p43() -> u64 {
    let mut digits: Vec<u64> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    let mut sum: u64 = 0;

    while digits != vec![9, 8, 7, 6, 5, 4, 3, 2, 1, 0] {
        permutate(&mut digits, 1);

        // make sure the number is 9 digit
        if digits[0] == 0 {
            continue;
        }

        // d2d3d4 must be divisible by 2 so digits[3] must be even
        if digits[3] % 2 != 0 {
            continue;
        }
        // d3d4d5 must be divisible by 3, so the sum of digits must be divisible by 3
        if (digits[2] + digits[3] + digits[4]) % 3 != 0 {
            continue;
        }

        // d4d5d6 must be divisible by 5 so digits[5] must be divisible by 5
        if digits[5] % 5 != 0 {
            continue;
        }

        // check d5d6d7 is divisible by 7
        let d5d6d7 = digits[4] * 100 + digits[5] * 10 + digits[6];
        if d5d6d7 % 7 != 0 {
            continue;
        }

        // check d6d7d8 is divisible by 11
        let d6d7d8 = digits[5] * 100 + digits[6] * 10 + digits[7];
        if d6d7d8 % 11 != 0 {
            continue;
        }

        // check d7d8d9 is divisible by 13
        let d7d8d9 = digits[6] * 100 + digits[7] * 10 + digits[8];
        if d7d8d9 % 13 != 0 {
            continue;
        }

        // check d8d9d10 is divisible by 17
        let d8d9d10 = digits[7] * 100 + digits[8] * 10 + digits[9];
        if d8d9d10 % 17 != 0 {
            continue;
        }

        sum += digits[0] * 1_000_000_000
            + digits[1] * 100_000_000
            + digits[2] * 10_000_000
            + digits[3] * 1_000_000
            + digits[4] * 100_000
            + digits[5] * 10_000
            + digits[6] * 1_000
            + digits[7] * 100
            + digits[8] * 10
            + digits[9];
    }
    sum
}

fn is_pentagnol(val: u64) -> bool {
    let test = ((((24 * val) + 1) as f64).sqrt() + 1f64) / 6f64;

    if test.floor() == test {
        return true;
    }
    return false;
}

// 5482660
pub fn p44() -> u64 {
    let mut pj = 5;

    for i in 3.. {
        let delta = 3 * i - 2;
        pj += delta;
        let mut j = i - 1;
        while j > 0 {
            let pk = j * (3 * j - 1) / 2;
            if is_pentagnol(pj + pk) && is_pentagnol(pj - pk) {
                return pj - pk;
            }
            j -= 1;
        }
    }
    0u64
}

pub fn p45() -> u64 {
    let mut i = 166;
    loop {
        let hexagonal = i * (2 * i - 1);
        if is_pentagonal(hexagonal) && is_triangle(hexagonal) {
            return hexagonal as u64;
        }
        i += 1;
    }
}

pub fn p46() -> u64 {
    let mut goldbach_works = [false; 60_000];
    let sieve_size = goldbach_works.len();
    let sieve = primal::Sieve::new(sieve_size);
    let double_squares: Vec<usize> = (0..sieve_size).map(|x| x * x * 2).collect();

    // pre fill the goldbach_works sieve with values for the prime 2 which is inconvienantly not odd
    for &double_square in &double_squares {
        let value: usize = double_square + 2;
        if value >= goldbach_works.len() {
            break;
        }
        goldbach_works[value] = true;
    }

    // for every odd number less in our range
    let mut i = 3;
    while i < sieve_size {
        // if it is a prime update our sieve
        if sieve.is_prime(i) {
            for &double_square in &double_squares {
                let value: usize = double_square + i;
                if value >= sieve_size {
                    break;
                }
                goldbach_works[value] = true;
            }
        } else
        // if it is a composite check if it disproves goltbach
        {
            // if odd and not a square of a composite + a prime
            if goldbach_works[i] == false {
                return i as u64;
            }
        }
        i += 2;
    }

    return 0;
}

pub fn p47() -> u64 {
    let mut i = 4;

    loop {
        let d = prime_factor_count(i + 3);
        if d != 4 {
            i += 4;
            continue;
        }

        let c = prime_factor_count(i + 2);
        if c != 4 {
            i += 3;
            continue;
        }
        let b = prime_factor_count(i + 1);
        if b != 4 {
            i += 2;
            continue;
        }
        let a = prime_factor_count(i + 0);
        if a != 4 {
            i += 1;
            continue;
        }
        return i as u64;
    }
}

pub fn p48() -> u64 {
    let mut sum = 0;
    let modval = 10_000_000_000;

    for i in 1..1_001 {
        sum += powmod(i, i, modval);
    }
    return (sum % modval) as u64;
}

pub fn p49() -> u64 {
    let sieve = primal::Sieve::new(9_999);
    let primes: Vec<usize> = sieve.primes_from(1_489).collect();

    // lets look at all the primes in range 1111 to 9999
    for i in 0..primes.len() {
        for j in i + 1..primes.len() {
            let k = primes[j] + (primes[j] - primes[i]);
            if k < 9_999 && sieve.is_prime(k) {
                // found 3 primes a in a sequence
                // check if they are permutations
                if is_3_perm(primes[i], primes[j], k) {
                    let value: u64 = (primes[i] * 100_000_000 + primes[j] * 10_000 + k) as u64;
                    return value;
                }
            }
        }
    }
    return 0_u64;
}

pub fn p50() -> u64 {
    let max_limit = 1_000_000;
    let sieve = primal::Sieve::new(max_limit);
    let primes: Vec<usize> = sieve.primes_from(1).collect();

    let mut consec_sum_prime = 0;
    let mut prime_sum_length = 0;

    for i in 0..primes.len() {
        let mut prime_sum = 0;
        for j in i..primes.len() {
            prime_sum += primes[j];
            if prime_sum > max_limit {
                break;
            }
            if sieve.is_prime(prime_sum) && j - i > prime_sum_length {
                prime_sum_length = j - i;
                consec_sum_prime = prime_sum;
            }
        }
    }
    consec_sum_prime as u64
}

// By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.
// By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.
// Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.

// 8 family sequence means it has to start with 0, 1 or 2
// obviously the last digit can't be one of the replaced digits
// we have to have 3 repeating digits
// the 7 prime sequence has 5 digits so assume 6 digits to start

// function to generate the candidate number out of the components we itorate over
fn generate_candidate(start: usize, last_digit: u8, pattern: [bool; 6], replacment: u8) -> usize {
    let mut candidate: usize = 0;
    let digits: [u8; 3] = [(start / 10) as u8, (start % 10) as u8, last_digit];
    let mut j = 0;
    //    println!("generate_candidate() start {} last_digit {} pattern {:?} replacment {}", start, last_digit, pattern, replacment );

    for i in 0..pattern.len() {
        candidate *= 10;
        if pattern[i] == true {
            candidate += replacment as usize;
        } else {
            candidate += digits[j] as usize;
            j += 1;
        }
    }
    //    println!("candidate {}", candidate );
    candidate
}

pub fn p51() -> u64 {
    // a true indicates we will replace this digit
    let patterns: [[bool; 6]; 10] = [
        [false, false, true, true, true, false],
        [false, true, false, true, true, false],
        [false, true, true, false, true, false],
        [false, true, true, true, false, false],
        [true, false, false, true, true, false],
        [true, false, true, false, true, false],
        [true, false, true, true, false, false],
        [true, true, false, false, true, false],
        [true, true, false, true, false, false],
        [true, true, true, false, false, false],
    ];
    let sieve = primal::Sieve::new(999_999);
    let last_digit: [u8; 4] = [1, 3, 7, 9]; // the possible last digits for a prime > 2

    // generate candidates and check if they satisy the requirements

    // the longest loop is generting the 3 non replaced digits
    // so do this at the outer layer so we only do it once
    for i in 11..24
    //100 // represents the first 2 digits
    {
        for j in 0..patterns.len() {
            let pattern = patterns[j];
            for k in 0..last_digit.len()
            // index into "last_digit"
            {
                // loop to check family
                let mut family_size = 0;
                let mut first_prime = 0;
                for replacment in 0..10 {
                    // skip leading zero's
                    if replacment == 0 && pattern[0] == true {
                        continue;
                    }
                    // if there are too many misses to make a family of 8
                    if replacment > family_size + 2 {
                        break;
                    }

                    let candidate: usize =
                        generate_candidate(i, last_digit[k], pattern, replacment);

                    if sieve.is_prime(candidate) {
                        family_size += 1;

                        if family_size == 8 {
                            return first_prime as u64;
                        }
                        if first_prime == 0 {
                            first_prime = candidate;
                        }
                    }
                }
            }
        }
    }

    return 0;
}

// It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.
// Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.

// obviously the first digit has to be a 1 and the number must contain most of a 2, 3, 4, 5 and 6
// 3*6 = 18 and 2*4 = 8 so I would guess there is an 8 also
// the example had 6 digits so I assume the answer must have at least 6 digits

pub fn p52() -> u64 {
    let mut candidate = 123456;
    loop {
        for i in 2..7 {
            if is_perm(candidate, candidate * i) == false {
                break;
            }
            if i == 6 {
                return candidate as u64;
            }
        }
        candidate += 1;
    }
}

// There are exactly ten ways of selecting three from five, 12345:
// 123, 124, 125, 134, 135, 145, 234, 235, 245, and 345

// In combinatorics, we use the notation, 5C3 = 10.

// In general,
// nCr =
// n!
// r!(n−r)!
// 	,where r ≤ n, n! = n×(n−1)×...×3×2×1, and 0! = 1.
// It is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.
// How many, not necessarily distinct, values of  nCr, for 1 ≤ n ≤ 100, are greater than one-million?

// loop over n values from 100 down, and r values from 1 up to c
// it seems the numbers get too big, so work with cancelled values
// that don't get to big and bail as soon as we hit one
pub fn p53() -> u64 {
    let mut sum: u64 = 0;
    let mut bail = false;

    // for n from 100 to 1
    for i in 0..100 {
        let n: u64 = 100 - i;
        let mut numerator: u128 = n as u128;
        let mut denominator: u128 = 1;
        for r in 1..n {
            if numerator / denominator > 1_000_000 {
                sum += n - 2 * r + 1;
                break;
            }
            // if we did not find a hit for any value of r
            // then we wont find any for smaller values of n
            if r + 1 == n {
                bail = true;
            }
            denominator *= (r + 1) as u128;
            numerator *= (n - r) as u128;
        }
        if bail == true {
            break;
        }
    }
    return sum;
}

// take a BigUint and add itself to its decimal reversal
fn reverse_and_add(value: num::BigUint) -> num::BigUint {
    let reverse_bytes: Vec<u8> = value.to_str_radix(10).bytes().rev().collect();

    value + BigUint::parse_bytes(&reverse_bytes, 10).unwrap()
}

// If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.

// Not all numbers produce palindromes so quickly. For example,

// 349 + 943 = 1292,
// 1292 + 2921 = 4213
// 4213 + 3124 = 7337

// That is, 349 took three iterations to arrive at a palindrome.

// Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome.
// A number that never forms a palindrome through the reverse and add process is called a Lychrel number.
// In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome.
// In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).
// Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.
// How many Lychrel numbers are there below ten-thousand?
pub fn p55() -> u64 {
    // 10k entry bitmask, bit is set when value has been calculated
    // works on 64bit machines
    let mut is_lychrel_bitmask: [usize; 10_000 / 8] = [0; 10_000 / 8];
    let mut lychrel_count: u64 = 0;

    // loop 9_999 times
    for i in 0..10_000 {
        let j = 9_999 - i; // j from 9_999 to 0
        let mut count = 1;
        let mut value = j.to_biguint().unwrap();
        let mut first_loop = true;

        loop {
            value = reverse_and_add(value);

            if bigint_is_dec_palendrome(&value) {
                break;
            }
            // only test the shortcut on the first loop
            if first_loop {
                let value_usize = value.to_string().parse::<usize>().unwrap();
                // if the value is in the correct range, we have checked it allready
                if value_usize < 10_000 {
                    // if we found it was lychrel then j is also lychrel
                    if is_lychrel_bitmask[value_usize / 64] & (1 << (value_usize % 64)) != 0 {
                        //                        println!("{} is lychrel because {} is lychrel", j, value_usize );
                        lychrel_count += 1;
                        is_lychrel_bitmask[j / 64] |= 1 << (j % 64);
                    }
                    break;
                }
                first_loop = false;
            }

            if count >= 50 {
                lychrel_count += 1;
                is_lychrel_bitmask[j / 64] |= 1 << (j % 64); // set the bit in the bitmask
                                                             //                println!( "{} is lychrel", j );
                break;
            }
            count += 1;
        }
    }

    lychrel_count
}

// sum the decimal digits of a number
pub fn sum_dec_digits(number: BigUint) -> u64 {
    let mut sum: u64 = 0;
    let byte_vec = number.to_str_radix(10).into_bytes();

    for byte in byte_vec {
        sum += (byte - 0x30) as u64;
    }
    sum
}

// calculate a to the power of b =
pub fn exp(mut number: BigUint, mut b: usize) -> BigUint {
    let mut result: BigUint = BigUint::from(1u32);

    loop {
        // if the lowest bit in the exponent is set
        if (b & 1) != 0 {
            // accumulate the current value
            result = result * number.clone();
        }
        b = b >> 1;
        // if we have accumulated all the bits
        if b == 0 {
            return result;
        }
        // square the number again
        number = number.clone() * number;
    }
}

// A googol (10^100) is a massive number: one followed by one-hundred zeros;
// 100^100 is almost unimaginably large: one followed by two-hundred zeros.
// Despite their size, the sum of the digits in each number is only 1.
// Considering natural numbers of the form, a^b, where a, b < 100, what is the maximum digital sum?

pub fn p56() -> u64 {
    let mut biggest = 0;
    let mut current;

    for i in 1..100 {
        let a = 100 - i;
        for j in 1..100 {
            let b = 100 - j;
            let power = exp(BigUint::from(a as u32), b);
            current = sum_dec_digits(power.clone());
            //            println!("a = {} b = {} exp = {}\n", i, j, power );
            if current > biggest {
                biggest = current;
            }
            // check if it is impossible to find a bigger digit sum
            else if power.to_str_radix(10).len() as u64 * 9u64 <= biggest {
                // if this was on the first inner loop we can quit the outer loop also
                if j == 1 {
                    return biggest;
                }
                break;
            }
        }
    }
    biggest
}

pub fn p57() -> u64 {
    let mut result: u64 = 0;

    let mut den: BigUint = BigUint::from(3u32);
    let mut num: BigUint = BigUint::from(2u32);

    for _i in 1..=1_000 {
        //        println!("num = {} den = {}", num, den );

        if num.to_str_radix(10).len() > den.to_str_radix(10).len() {
            result += 1;
        }

        num = num + (den.clone() * 2u32);
        den = num.clone() - den;
    }

    result
}

// Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.
//
// 37 36 35 34 33 32 31
// 38 17 16 15 14 13 30
// 39 18  5  4  3 12 29
// 40 19  6  1  2 11 28
// 41 20  7  8  9 10 27
// 42 21 22 23 24 25 26
// 43 44 45 46 47 48 49
//
// It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.
//
// If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?

pub fn p58() -> u64 {
    let sieve = primal::Sieve::new(700_000_000);
    let mut prime_count = 0;
    let mut total_count = 0;
    let mut side_length = 2;
    let mut value = 1;

    loop {
        value += side_length; // the lower right corner is never prime so don't check this one
        for _i in 0..3 {
            if sieve.is_prime(value) {
                prime_count += 1;
            }
            value += side_length;
        }
        total_count += 4;
        if ((prime_count * 100) / total_count) < 10 {
            return (side_length - 1) as u64;
        }
        side_length += 2;
    }
}

pub fn p59() -> u64 {
    let mut file = File::open("p059_cipher.txt").expect("file open error");
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .expect("Coult not read file");
    let words: Vec<&str> = contents.split(',').collect();
    let mut output: Vec<char> = Vec::new();
    for word in words {
        if let Ok(num) = i32::from_str_radix(word, 10) {
            let out_char: char = num as u8 as char;
            output.push(out_char);
        }
    }

    let mut counts = vec![vec![0; 128], vec![0; 128], vec![0; 128]];

    // assuming that a space is the most common character
    // we can find the most common value and knowning it is the key XOR a space charactor
    // work out the key

    // count the characters in 3 columbs, and keep track of the largest number
    let mut i = 0;
    let mut chars = vec![' ', ' ', ' '];
    let mut max_counts = vec![0, 0, 0];
    for character in output.clone() {
        counts[i][character as usize] += 1;
        if counts[i][character as usize] >= max_counts[i] {
            max_counts[i] = counts[i][character as usize];
            chars[i] = character;
            //           println!("new max count row {}, count {}, for char {}", i, max_counts[i], chars[i] );
        }
        i += 1;
        if i >= 3 {
            i = 0;
        }
    }

    // XOR with space to get key
    while i < chars.len() {
        chars[i] = (chars[i] as u8 ^ ' ' as u8) as char;
        i += 1;
    }

    //    println!("key = {}{}{}", chars[0], chars[1], chars[2] );

    // use the key to decode the text and sum the chars
    let mut sum: u64 = 0;
    i = 0;
    for character in output {
        let decoded_char = (character as u8 ^ chars[i] as u8) as char;
        //        print!("{}", decoded_char );
        sum += decoded_char as u64;
        i += 1;
        if i >= 3 {
            i = 0;
        }
    }
    return sum;
}



// The primes 3, 7, 109, and 673, are quite remarkable. 
// By taking any two primes and concatenating them in any order the result will always be prime. 
// For example, taking 7 and 109, both 7109 and 1097 are prime. 
// The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property.
//
// Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.
//
pub fn p60() -> u64 {
    let sieve = primal::Sieve::new(4_200_000_000);
    let mut prime_iter_a = sieve.primes_from(3);
    let mut lowest_sum: u64 = 0;
    let max_prime = 30_000;

    // outer loop, providing prime a
    loop {
        if let Some(a) = prime_iter_a.next() {
//            println!("a {}", a);
            if a > max_prime {
                break;
            }
            // next loop providing prime b
            let mut prime_iter_b = sieve.primes_from(a);
            loop {
                if let Some(b) = prime_iter_b.next() { 
//                    println!("a b {} {} ", a, b);
                    if b > max_prime {
                        break;
                    }
                    if !concat_is_prime(a, b, &sieve) {
                        continue;
                    }

                    // next loop providing prime c
                    let mut prime_iter_c = sieve.primes_from(b);
                    loop {
                        if let Some(c) = prime_iter_c.next() {
//                        println!("a b c {} {} {}", a, b, c );
                            if c > max_prime
                            {
                                break;
                            }
                            if !concat_is_prime(a, c, &sieve) ||
                               !concat_is_prime(b, c, &sieve) {
                                continue;
                            }
//                            println!("a b c {} {} {}", a, b, c);
                            // next loop providing d
                            let mut prime_iter_d = sieve.primes_from(c);
                            loop {
                                if let Some(d) = prime_iter_d.next() {
                                    if d > max_prime
                                    {
                                        break;
                                    }
                                    if !concat_is_prime(a, d, &sieve) ||
                                       !concat_is_prime(b, d, &sieve) ||
                                       !concat_is_prime(c, d, &sieve) {
                                            continue;
                                        }
//                                    println!("a b c d {} {} {} {}", a, b, c, d);
                                    // innermost loop providing e
                                    let mut prime_iter_e = sieve.primes_from(d);
                                    loop {
                                        if let Some(e) = prime_iter_e.next() { 
                                            if e > max_prime
                                            {
                                                break;
                                            }
                                            if !concat_is_prime( a, e, &sieve ) ||
                                               !concat_is_prime( b, e, &sieve ) ||
                                               !concat_is_prime( c, e, &sieve ) ||
                                               !concat_is_prime( d, e, &sieve ) {
                                                    continue;
                                                }
                                            // ok here we have a candidate, check if it is the smallest
                                            if lowest_sum == 0
                                                || ((a + b + c + d + e) as u64)
                                                    < lowest_sum
                                            {
                                                lowest_sum =
                                                    (a + b + c + d + e) as u64;
//                                                 println!("got a={} b={} c={} d={} e={} {}", a,b,c,d,e,lowest_sum);                                                                    
                                            }
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    break;
                                }
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
                else {
                    break;
                }
            }
        }
        else {
            break;
        }
    }
    lowest_sum
}


// recursive helper function for p61
pub fn has_match( bags : &mut Vec<Vec<u32>>, high_digits: u32, low_digits : u32, results: &mut Vec<u32> ) -> bool {
    let mut cnt : usize = 0;

    for bag in bags.iter(){
        let mut new_bags = bags.clone();
        new_bags.remove(cnt); // remove the current polygonal set from the new vec
        for i in bag.iter() {
            if *i % 100 == high_digits {
                // if we are on the last digit check if the high digits match the low digits of the original
                if new_bags.len() == 0 {
                    if i/100 == low_digits {
                        results.push(*i); // add the value to the results 
                        return true;
                    }
                    continue;
                }

                // check if there is a match remaining
                if has_match(&mut new_bags,(i)/100u32, low_digits, results) {

                    results.push(*i); // add the value to the results  
                    return true;
                }
            }
        }
        cnt += 1;
    }
    results.clear();
    return false;
}


// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
// triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
pub fn p61() -> u64 {
    let mut octagonal:Vec<u32> = Vec::new();
    let mut heptagonal:Vec<u32> = Vec::new();
    let mut hexagonal:Vec<u32> = Vec::new();
    let mut pentagonal:Vec<u32> = Vec::new();
    let mut square:Vec<u32> = Vec::new();
    let mut triangle:Vec<u32> = Vec::new();
    let mut results: Vec<u32> = Vec::new();

    // build hashsets of the 4 digit polygonal numbers
    for i in 1..1000 {
        let triangle_value: u32 = i*(i+1)/2;
        // we only need 4 digit values
        // so we don't need values less than 1000

        // and we don't need values greated than 9999
        if triangle_value > 9999 {
            break;
        }
        if triangle_value > 1000 {
            triangle.push(triangle_value);
        }
        
        let square_value: u32 = i*i;
        if square_value > 9999 {
            continue;
        }
        if square_value > 1000 {
            square.push(square_value);
        }
        let pentagon_value: u32 = i*((3*i)-1)/2;
        if pentagon_value > 9999 {
            continue;
        }
        if pentagon_value > 1000 {
            pentagonal.push(pentagon_value);
        }
        let hexavon_value: u32 = i*((2*i)-1);
        if hexavon_value > 9999 {
            continue;
        }
        if hexavon_value > 1000 {
            hexagonal.push(hexavon_value);
        }
        let heptagon_value: u32 = i*((5*i)-3)/2;
        if heptagon_value > 9999 {
            continue;
        }
        if heptagon_value > 1000 {
            heptagonal.push(heptagon_value);
        }
        let octagon_value: u32 = i*((3*i)-2);
        if octagon_value > 9999 {
            continue;
        }
        if octagon_value > 1000 {
            octagonal.push(octagon_value);
        }
    }

 // make a vector of our hashsets
    let mut polygonal = Vec::new();
    polygonal.push(heptagonal);
    polygonal.push(hexagonal);
    polygonal.push(pentagonal);
    polygonal.push(square);
    polygonal.push(triangle);

    // because the octagonal set should have the least numbers
    // start by iterating over that set and checking for 2 digit cycles
    // in the other sets

    for i in octagonal{
        let mut poly_set = polygonal.clone();
        if has_match( &mut poly_set, i/100, i%100, &mut results ){       
            let mut sum = i;
            for value in results {
                sum += value;
            }
            return sum as u64;
        }
    }

    0
}




// The cube, 41063625 (3453), can be permuted to produce two other cubes: 56623104 (3843) and 66430125 (4053). 
// In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.

// Find the smallest cube for which exactly five permutations of its digits are cube.

pub fn p62() -> u64 {

    struct Value {
        smallest_cube: u64,  // the smallest cube that match the digits in the vec
        count: u32,         // the count of matches for these digits
    }  

    // the key is the sorted list of digits of the value cubed
    let mut matches: HashMap<String, Value>= HashMap::new();
    let mut cube : u64 = 11;

    loop {
        let cubed: u64 = cube*cube*cube;
        let digits = cubed.to_string();
        let mut chars: Vec<char> =digits.chars().collect();
        chars.sort();
        let mut sorted = String::new();
        for c in chars {
            sorted.push(c);
        }

        if let Some( mut update ) = matches.get_mut(&sorted) {
            // update the existing entry
            update.count += 1;
            if update.count >= 5 {
//                println!("smallest = {} largest = {} largest cube = {} ordered = {}", update.smallest_cube, cube, cubed, sorted);
                return update.smallest_cube;
            }
        }
        else
        {
            // inset a new entry 
            let new_entry = Value {
                smallest_cube : cubed as u64,
                count : 1,
            };
            matches.insert(sorted, new_entry);
        }
        cube += 1;
    }
}

